package com.gg.gpos.reference.manager;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import org.springframework.web.multipart.MultipartFile;

import com.gg.gpos.common.constant.CountAbsolutePathEnum;
import com.gg.gpos.common.constant.FunctionTypeEnum;
import com.gg.gpos.common.constant.ModuleTypeEnum;
import com.gg.gpos.common.constant.SizeImageEnum;
import com.gg.gpos.common.constant.SizeVideoEnum;
import com.gg.gpos.common.constant.SymbolEnum;
import com.gg.gpos.common.constant.SyncStatusEnum;
import com.gg.gpos.common.constant.TmpSyncTypeEnum;
import com.gg.gpos.common.util.SpringUploadUtil;
import com.gg.gpos.common.util.UploadedFile;
import com.gg.gpos.menu.dto.CoCategoryDto;
import com.gg.gpos.reference.dto.AttachmentDto;
import com.gg.gpos.reference.entity.Attachment;
import com.gg.gpos.reference.mapper.AttachmentMapper;
import com.gg.gpos.reference.repository.AttachmentRepository;
import com.gg.gpos.reference.search.AttachmentSpecification;

import lombok.extern.slf4j.Slf4j;

/**
 * Generated by Speed Generator
 * 
 * @author <a href="mailto:ngtrungkien@gmail.com">Kien Nguyen</a>
 */
@Slf4j
@Service
public class AttachmentManager{
	@Autowired
	private AttachmentRepository attachmentRepository;
	@Autowired
	private AttachmentMapper attachmentMapper;
	@Autowired
	private AttachmentSpecification attachmentSpecification;
	
	public void saveAttachment(MultipartFile multipartFile, String attachmentPath, String attachmentContextPath, Long moduleId, String moduleType, String functionType, Integer restaurantCode, String moduleCode) {
		log.debug("PROCESS: SAVE IMAGE ATTACHMENT, MODULE_ID: {}, MODULE_TYPE: {}, FUNCTION_TYPE: {}", moduleId, moduleType, functionType);
		try {
			String[] arr = {"jpg","jpeg","png","gif","tiff","pjp","pjpeg","jfif","tif","svg","bmp","svgz","webp","ico","xbm","dib"};
			List<String> fileType = Arrays.asList(arr);
			if (multipartFile != null && multipartFile.getSize() > 0) {
				Attachment attachmentExisting = getAttachment(moduleId, moduleType, functionType);
				if(attachmentExisting != null) {
					if (StringUtils.isNotBlank(attachmentExisting.getAbsolutePath())) {
						Long countByAbsolutePath = attachmentRepository.countByAbsolutePath(attachmentExisting.getAbsolutePath());
						if(countByAbsolutePath == 1) {
							if(Paths.get(attachmentExisting.getAbsolutePath()) != null) {
								Files.deleteIfExists(Paths.get(attachmentExisting.getAbsolutePath()));
							}
						}
					}
					attachmentRepository.delete(attachmentExisting);
				}
				Attachment attachment = new Attachment();
				String fileName = multipartFile.getOriginalFilename();
				if(fileName != null && StringUtils.isNotBlank(fileName) && !checkErr(fileName)) {
					String fileTypeImg  = StringUtils.substringAfterLast(fileName, SymbolEnum.DOT.val).toLowerCase();
					Long fileSizeImg = multipartFile.getSize();
					Integer sizeImageStandard = SizeImageEnum.CO_CATEGORY_SIZE.sizeImage;
					if(moduleType.equals(ModuleTypeEnum.CO_FOOD_ITEM.val)) {
						sizeImageStandard = SizeImageEnum.CO_FOODITEM_SIZE.sizeImage;
					}
					if(fileTypeImg != null && fileType.contains(fileTypeImg) && fileSizeImg <= sizeImageStandard) {
						StringBuilder buffer = new StringBuilder();
						buffer.append(moduleType).append(File.separator).append(functionType).append(File.separator).append(moduleId);
						String idFolder = buffer.toString();
						String uploadFolder = attachmentPath + idFolder;
						String absolutePath = uploadFolder + File.separator + multipartFile.getOriginalFilename();
						String url = attachmentContextPath + idFolder + File.separator + multipartFile.getOriginalFilename();

						attachment.setModuleType(moduleType);
						attachment.setModuleId(moduleId);
						attachment.setModuleCode(moduleCode);
						attachment.setRestaurantCode(restaurantCode);
						attachment.setFunctionType(functionType);
						attachment.setFileName(multipartFile.getOriginalFilename());
						attachment.setFileType(StringUtils.substringAfterLast(multipartFile.getOriginalFilename(), SymbolEnum.DOT.val));
						attachment.setAbsolutePath(absolutePath);
						attachment.setUrl(url);
						attachment = attachmentRepository.save(attachment);

						if (attachment.getId() != null) {
							UploadedFile uploadedFile = new UploadedFile();
							uploadedFile.setUploadedPath(uploadFolder);
							uploadedFile.setUploadedFileName(multipartFile.getOriginalFilename());
							uploadedFile.setUploadedFileContent(multipartFile.getBytes());
							SpringUploadUtil.uploadFile(uploadedFile);
						}
					}
				}
			}
		} catch (Exception e) {
			log.error("ERROR: PROCESS: SAVE ATTACHMENT EXCEPTION: {}", e);
		}
	}	
	
	public void saveAttachments(List<MultipartFile> multipartFiles, final String attachmentPath, final String attachmentContextPath, final Long moduleId, final String moduleType, final String functionType, Integer restaurantCode, String moduleCode) throws IOException {
		log.debug("PROCESS: SAVE ATTACHMENT, MODULE_ID: {}, MODULE_TYPE: {}, FUNCTION_TYPE: {}", moduleId, moduleType, functionType);
		
		String[] arr = {"jpg","jpeg","png","gif","tiff","pjp","pjpeg","jfif","tif","svg","bmp","svgz","webp","ico","xbm","dib"};
		List<String> fileType = Arrays.asList(arr);
		if (multipartFiles != null && !multipartFiles.isEmpty()) {
			List<Attachment> attachmentExistings = getAttachments(moduleId, moduleType, functionType);
			List<MultipartFile> filterMultipartFiles = multipartFiles.stream().filter(f -> {
				return f.getSize() > 0;
			}).collect(Collectors.toList());
			
			if (!filterMultipartFiles.isEmpty()) {
				
				// Xóa các phần tử có tên trùng
				if(!CollectionUtils.isEmpty(attachmentExistings)) {
					List<String> fileNames = filterMultipartFiles.stream().map(item -> item.getOriginalFilename()).collect(Collectors.toList());
					attachmentExistings.stream().forEach(attachmentExisting ->{
						if (fileNames.contains(attachmentExisting.getFileName()) && StringUtils.isNotBlank(attachmentExisting.getAbsolutePath())) {
							Long countByAbsolutePath = attachmentRepository.countByAbsolutePath(attachmentExisting.getAbsolutePath());
							if(countByAbsolutePath == 1) {
								if(Paths.get(attachmentExisting.getAbsolutePath()) != null) {
									try {
										Files.deleteIfExists(Paths.get(attachmentExisting.getAbsolutePath()));
									} catch (IOException e) {
										e.printStackTrace();
									}
								}
							}
							attachmentRepository.delete(attachmentExisting);
						}
					});
				}
				
				
				// Insert new images and collect images that marked for removing
				filterMultipartFiles.forEach(multipartFile -> {
					String fileName = multipartFile.getOriginalFilename();
					if(fileName != null && StringUtils.isNotBlank(fileName) && !checkErr(fileName)) {
						String fileTypeImg  = StringUtils.substringAfterLast(fileName, SymbolEnum.DOT.val).toLowerCase();
						Long fileSizeImg = multipartFile.getSize();
						if(fileTypeImg != null && fileType.contains(fileTypeImg) && fileSizeImg <= SizeImageEnum.SIZE.sizeImage  ) {
							StringBuilder buffer = new StringBuilder();
							buffer.append(moduleType).append(File.separator).append(functionType).append(File.separator).append(moduleId);
							String idFolder = buffer.toString();
							String uploadFolder = attachmentPath + idFolder;
							String absolutePath = uploadFolder + File.separator + multipartFile.getOriginalFilename();
							String url = attachmentContextPath + idFolder + File.separator + multipartFile.getOriginalFilename();
							
							Attachment attachment = new Attachment();
							attachment.setModuleType(moduleType);
							attachment.setModuleId(moduleId);
							attachment.setRestaurantCode(restaurantCode);
							attachment.setModuleCode(moduleCode);
							attachment.setFunctionType(functionType);
							attachment.setFileName(multipartFile.getOriginalFilename());
							attachment.setFileType(StringUtils.substringAfterLast(multipartFile.getOriginalFilename(), SymbolEnum.DOT.val));
							attachment.setAbsolutePath(absolutePath);
							attachment.setUrl(url);
							attachment = attachmentRepository.save(attachment);

							if (attachment.getId() != null) {
								try {
									UploadedFile uploadedFile = new UploadedFile();
									uploadedFile.setUploadedPath(uploadFolder);
									uploadedFile.setUploadedFileName(multipartFile.getOriginalFilename());
									uploadedFile.setUploadedFileContent(multipartFile.getBytes());
									SpringUploadUtil.uploadFile(uploadedFile);
								} catch (IOException e) {
									log.error("ERROR: UPLOAD FILE EXCEPTION: {}", e);
								}
							}
						}
					}
					
				});
			}
		}
	}
	
	public void saveVideoAttachment(MultipartFile multipartFile, String attachmentPath, String attachmentContextPath, Long moduleId, String moduleType, String functionType, Integer restaurantCode, String moduleCode)	throws IOException {
		log.debug("PROCESS: SAVE VIDEO ATTACHMENT, MODULE_ID: {}, MODULE_TYPE: {}, FUNCTION_TYPE: {}", moduleId, moduleType, functionType);
		try {
			String[] arr = {"ogm","wmv","mpg","webm","ogv","mov","asx","mpeg","mp4","m4v","avi","mov","flv"};
			List<String> fileType = Arrays.asList(arr);
			if (multipartFile != null && multipartFile.getSize() > 0) {
				// Xóa file cũ
				Attachment attachmentExisting = getAttachment(moduleId, moduleType, functionType);
				if(attachmentExisting != null) {
					if (StringUtils.isNotBlank(attachmentExisting.getAbsolutePath())) {
						Long countByAbsolutePath = attachmentRepository.countByAbsolutePath(attachmentExisting.getAbsolutePath());
						if(countByAbsolutePath == 1) {
							if(Paths.get(attachmentExisting.getAbsolutePath()) != null) {
								Files.deleteIfExists(Paths.get(attachmentExisting.getAbsolutePath()));
							}
						}
					}
					attachmentRepository.delete(attachmentExisting);
				}
				// Insert file mới
				Attachment attachment = new Attachment();
				String fileName = multipartFile.getOriginalFilename();
				if(fileName != null && StringUtils.isNotBlank(fileName) && !checkErr(fileName)) {
					String fileTypeImg  = StringUtils.substringAfterLast(fileName, SymbolEnum.DOT.val).toLowerCase();
					Long fileSizeImg = multipartFile.getSize();
					if(fileTypeImg != null && fileType.contains(fileTypeImg) && fileSizeImg <= SizeVideoEnum.SIZE_VIDEO.size) {
						StringBuilder buffer = new StringBuilder();
						buffer.append(moduleType).append(File.separator).append(functionType).append(File.separator).append(moduleId);
						String idFolder = buffer.toString();
						String uploadFolder = attachmentPath + idFolder;
						String absolutePath = uploadFolder + File.separator + multipartFile.getOriginalFilename();
						String url = attachmentContextPath + idFolder + File.separator + multipartFile.getOriginalFilename();

						attachment.setModuleType(moduleType);
						attachment.setModuleId(moduleId);
						attachment.setFunctionType(functionType);
						attachment.setModuleCode(moduleCode);
						attachment.setRestaurantCode(restaurantCode);
						attachment.setFileName(multipartFile.getOriginalFilename());
						attachment.setFileType(StringUtils.substringAfterLast(multipartFile.getOriginalFilename(), SymbolEnum.DOT.val));
						attachment.setAbsolutePath(absolutePath);
						attachment.setUrl(url);
						attachment = attachmentRepository.save(attachment);

						if (attachment.getId() != null) {
							UploadedFile uploadedFile = new UploadedFile();
							uploadedFile.setUploadedPath(uploadFolder);
							uploadedFile.setUploadedFileName(multipartFile.getOriginalFilename());
							uploadedFile.setUploadedFileContent(multipartFile.getBytes());
							SpringUploadUtil.uploadFile(uploadedFile);
						}
					}
				}
			}
		} catch (Exception e) {
			log.error("ERROR: PROCESS: SAVE VIDEO ATTACHMENT EXCEPTION: {}", e);
		}
	}	
	
	public void deleteAttachment(Long moduleId, String moduleType, String functionType) {
		log.debug("PROCESS: DELETE ATTACHMENT, MODULE_ID : {}, MODULE_TYPE: {}, FUNCTION_TYPE: {}", moduleId, moduleType, functionType);
		try {
			List<Attachment> attachments =  attachmentRepository.findByModuleIdAndModuleTypeAndFunctionType(moduleId, moduleType, functionType);
			if(attachments != null && !attachments.isEmpty()) {
				attachments.forEach(attachment -> {
					if (StringUtils.isNotBlank(attachment.getAbsolutePath())) {
						Long countByAbsolutePath = attachmentRepository.countByAbsolutePath(attachment.getAbsolutePath());
						if(countByAbsolutePath == 1) {
							if(Paths.get(attachment.getAbsolutePath()) != null) {
								try {
									Files.deleteIfExists(Paths.get(attachment.getAbsolutePath()));
								} catch (IOException e) {
									e.printStackTrace();
								}
							}
						}
					}
					attachmentRepository.delete(attachment);
				});
			}
		} catch (Exception e) {
			log.error("ERROR: PROCESS: DELETE ATTACHMENT EXCEPTION: {}", e);
		}
	}
	
	
	public void deleteById(Long id) {
		log.debug("PROCESS: DELETE ATTACHMENT, ID : {}", id);
		try {
			Optional<Attachment> attachmentOptional = attachmentRepository.findById(id);
			if(attachmentOptional.isPresent()) {
				Attachment attachment = attachmentOptional.get();
				if (StringUtils.isNotBlank(attachment.getAbsolutePath())) {
					Long countByAbsolutePath = attachmentRepository.countByAbsolutePath(attachment.getAbsolutePath());
					if(countByAbsolutePath == 1) {
						if(Paths.get(attachment.getAbsolutePath()) != null) {
							try {
								Files.deleteIfExists(Paths.get(attachment.getAbsolutePath()));
							} catch (IOException e) {
								e.printStackTrace();
							}
						}
					}
				}
				attachmentRepository.delete(attachment);
			}
		} catch (Exception e) {
			log.error("ERROR: PROCESS: DELETE ATTACHMENT EXCEPTION: {}", e);
		}
	}
	
	public void deleteByModuleIdAndModuleType(Long moduleId, String moduleType) {
		log.debug("PROCESS: DELETE ATTACHMENTS, MODULE_ID : {}, MODULE_TYPE: {}", moduleId, moduleType);
		List<Attachment> attachmentExistings =  attachmentRepository.findByModuleIdAndModuleType(moduleId, moduleType);
		if(!CollectionUtils.isEmpty(attachmentExistings)) {
			attachmentExistings.forEach(attachment -> {
				if (StringUtils.isNotBlank(attachment.getAbsolutePath())) {
					Long countByAbsolutePath = attachmentRepository.countByAbsolutePath(attachment.getAbsolutePath());
					if(countByAbsolutePath == 1) {
						if(Paths.get(attachment.getAbsolutePath()) != null) {
							try {
								Files.deleteIfExists(Paths.get(attachment.getAbsolutePath()));
							} catch (IOException e) {
								e.printStackTrace();
							}
						}
					}
				}
				attachmentRepository.delete(attachment);
			});
		}
	}
	
	public AttachmentDto getAttachmentDto(final Long moduleId, final String moduleType, final String functionType) {
		AttachmentDto attachment = null;
		List<AttachmentDto> attachments = attachmentRepository.findByModuleIdAndModuleTypeAndFunctionType(moduleId, moduleType, functionType).stream().map(attachmentMapper::entityToDto).collect(Collectors.toList());
		if (attachments != null && !attachments.isEmpty()) {
			attachment = attachments.get(0);
		} else {
			attachment = new AttachmentDto();
		}

		return attachment;
	}
	
	public AttachmentDto getByModuleIdAndModuleTypeAndFunctionType(Long moduleId, String moduleType, String functionType) {
		log.debug("PROCESS: GET ATTACHMENT, MODULE_ID: {}, MODULE_TYPE: {}, FUNTION_TYPE: {}", moduleId, moduleType, functionType);
		AttachmentDto attachment = new AttachmentDto();
		List<AttachmentDto> attachments = attachmentRepository.findByModuleIdAndModuleTypeAndFunctionType(moduleId, moduleType, functionType).stream().map(attachmentMapper::entityToDto).collect(Collectors.toList());
		if (!CollectionUtils.isEmpty(attachments)) {
			attachment = attachments.get(0);
		}
		return attachment;
	}
	
	public List<AttachmentDto> getsByStatusFail() {
		log.debug("PROCESS: GETS BY STATUS FAIL");
		return attachmentRepository.findBySyncStatus(SyncStatusEnum.FAIL.val).stream().map(attachmentMapper::entityToDto).collect(Collectors.toList());
	}
	
	public void updateRestaurantCodeAndModoleCode(Long moduleId, String moduleType, String moduleCode, Integer restaurantCode, String restaurantName) {
		log.debug("PROCESS: UPDATE RESTAURANT_CODE AND MODULE_CODE, MODULE_TYPE: {}, RESTAURANT_CODE: {}, MODULE_CODE: {}", moduleType, restaurantCode, moduleCode);
		try {
			List<Attachment> attachments =  attachmentRepository.findByModuleIdAndModuleType(moduleId, moduleType);
			if(!CollectionUtils.isEmpty(attachments)) {
				attachments.stream().forEach(item ->{
					item.setModuleCode(moduleCode);
					item.setRestaurantName(restaurantName);
					item.setRestaurantCode(restaurantCode);
					attachmentRepository.save(item);
				});
			}
		} catch (Exception e) {
			log.debug("ERROR PROCESS: UPDATE RESTAURANT_CODE AND MODULE_CODE: {}", e);
		}
	}
	
	public List<AttachmentDto> getByTmpSyncType(String tmpSyncType, Long moduleId) {
		log.debug("PROCESS: GETS BY TMP_SYNC TYPE");
		if(tmpSyncType.equals(TmpSyncTypeEnum.CO_FOOD_ITEM.val)) {
			return attachmentRepository.findByModuleIdAndModuleTypeAndFunctionTypeNot(moduleId, ModuleTypeEnum.CO_FOOD_ITEM.val, FunctionTypeEnum.QR_ORDER_PHOTO.val).stream().map(attachmentMapper::entityToDto).collect(Collectors.toList());
		} else if(tmpSyncType.equals(TmpSyncTypeEnum.CO_CATEGORY.val)) {
			return attachmentRepository.findByModuleIdAndModuleType(moduleId, ModuleTypeEnum.CO_CATEGORY.val).stream().map(attachmentMapper::entityToDto).collect(Collectors.toList());
		} else {
			return attachmentRepository.findByModuleIdAndModuleType(moduleId, ModuleTypeEnum.FOOD_GROUP.val).stream().map(attachmentMapper::entityToDto).collect(Collectors.toList());
		}
	}
	
	public void updateAttachment(Long id, Integer resCode ,String result,String code,String resName) {
		Optional<Attachment> attachmentOptional = attachmentRepository.findById(id);
		if(attachmentOptional.isPresent()) {
			Attachment attachment = attachmentOptional.get();
			if(attachment != null) {
				attachment.setSyncStatus(result);
				attachment.setRestaurantCode(resCode);
				attachment.setRestaurantName(resName);
				attachment.setModuleCode(code);
				attachmentRepository.save(attachment);
			}
		}
	}
	
	public Page<AttachmentDto> gets(AttachmentDto criteria) {
		log.debug("Entering 'gets(criteia)' method...");
		Page<Attachment> page = attachmentRepository.findAll(attachmentSpecification.search(criteria.getRestaurantCode(),SyncStatusEnum.FAIL.val), PageRequest.of(criteria.getPage(), criteria.getSize()));
		return new PageImpl<>(page.getContent().stream().map(attachmentMapper::entityToDto).collect(Collectors.toList()), PageRequest.of(criteria.getPage(), criteria.getSize()), page.getTotalElements());
	}
	
	public void saveAttachmentAfterSync(Long id, Integer resCode ,String result,String code,String resName) {
		Optional<Attachment> attachmentOptional = attachmentRepository.findById(id);
		if(attachmentOptional.isPresent()) {
			Attachment attachment = attachmentOptional.get();
			if(attachment != null) {
				attachment.setSyncStatus(result);
				attachment.setRestaurantCode(resCode);
				attachment.setRestaurantName(resName);
				attachment.setModuleCode(code);
				attachmentRepository.save(attachment);
			}
		}
	}
	
	public void delAttAfterSync(String moduleType) {
		log.debug("PROCESS: DELETE ATTACHMENT AFTER SYNC BY MODULE_TYPE, MODULE_TYPE: {}", moduleType);
		List<Attachment> attachments =  attachmentRepository.findByModuleTypeAndFunctionTypeIsNullAndModuleIdIsNull(moduleType);
		if(attachments != null && !attachments.isEmpty()) {
			attachments.forEach(attachment -> {
				Long countByAbsolutePath = attachmentRepository.countByAbsolutePath(attachment.getAbsolutePath());
				if(countByAbsolutePath.equals(CountAbsolutePathEnum.ONE.val)) {
					try {
						Files.deleteIfExists(Paths.get(attachment.getAbsolutePath()));
						attachmentRepository.delete(attachment);
					} catch (IOException e) {
						attachmentRepository.delete(attachment);
						log.error("ERROR DELETE ATTACHMENT AFTER SYNC BY MODULE_TYPE EXCEPTION: {}", e);
					}
				}else {
					attachmentRepository.delete(attachment);
				}
			});
		}
	}
	
	public void delete(final Long moduleId, final String moduleType , String functionType) {
		List<Attachment> attachments =  attachmentRepository.findByModuleIdAndModuleTypeAndFunctionType(moduleId, moduleType, functionType);
		if(!CollectionUtils.isEmpty(attachments)) {
			attachments.forEach(attachment -> {
				attachmentRepository.delete(attachment);
			});
		}
	}
	
	public List<Attachment> getAttachments(final Long moduleId){
		return attachmentRepository.findByModuleId(moduleId);
	}
	
	public Attachment getAttachment(final Long moduleId, final String moduleType, final String functionType) {
		Attachment attachment = null;
		List<Attachment> attachments = attachmentRepository.findByModuleIdAndModuleTypeAndFunctionType(moduleId, moduleType, functionType);
		if (attachments != null && !attachments.isEmpty()) {
			attachment = attachments.get(0);
		} else {
			attachment = new Attachment();
		}

		return attachment;
	}
	
	public List<AttachmentDto> getByModuleIdAndModuleType(final Long moduleId, final String moduleType){
		List<AttachmentDto> attachments = attachmentRepository.findByModuleIdAndModuleType(moduleId, moduleType).stream().map(attachmentMapper::entityToDto).collect(Collectors.toList());
		return attachments;
	}
	
	public List<AttachmentDto> getAttachmentDtos(final Long moduleId, final String moduleType, final String functionType) {
		return attachmentRepository.findByModuleIdAndModuleTypeAndFunctionType(moduleId, moduleType, functionType).stream().map(attachmentMapper::entityToDto).collect(Collectors.toList());
	}
	
	public List<Attachment> getAttachments(final Long moduleId, final String moduleType, final String functionType) {
		return attachmentRepository.findByModuleIdAndModuleTypeAndFunctionType(moduleId, moduleType, functionType);
	}
	
	public List<AttachmentDto> gets(Long cId){
		List<Attachment> attachments = attachmentRepository.findByModuleIdAndModuleTypeAndFunctionType(cId,ModuleTypeEnum.CO_FOOD_ITEM.val,FunctionTypeEnum.IMAGES.val);
		List<AttachmentDto> attachmentDtos = attachments.stream().map(a ->{
			AttachmentDto attachmentDto = new AttachmentDto();
			BeanUtils.copyProperties(a, attachmentDto);
			return attachmentDto;
		}).collect(Collectors.toList());

		return attachmentDtos;
	}
	
	public void save(List<AttachmentDto> attachmentDtos, String attachmentPath, String contextPath) {
		log.debug("Entering 'save' method...");
//		contextPath = contextPath.substring(0, contextPath.length()-1);
		attachmentPath = attachmentPath.substring(0, attachmentPath.length()-11);
		if(attachmentDtos != null && !attachmentDtos.isEmpty()) {
			//Xóa images cũ
			attachmentDtos.stream().forEach(att -> {
				List<Attachment> attachments = attachmentRepository.findByModuleIdAndModuleTypeAndFunctionType(att.getModuleId(), att.getModuleType(), att.getFunctionType());
				if(attachments != null && !attachments.isEmpty()) {
					attachments.stream().forEach(attachment ->{
						if(StringUtils.isNotBlank(attachment.getAbsolutePath())) {
							Long countAbsolutePath = attachmentRepository.countByAbsolutePath(attachment.getAbsolutePath());
							if(countAbsolutePath == 1) {
								try {
									Files.deleteIfExists(Paths.get(attachment.getAbsolutePath()));
									attachmentRepository.delete(attachment);
								} catch (IOException e) {
									log.error(e.getMessage());
								}
							}else {
								attachmentRepository.delete(attachment);
							}
						}
					});
				}
			});
			
			//Tạo mới data
			for(AttachmentDto att: attachmentDtos) {
				Attachment attachment = Optional.ofNullable(att).map(attachmentMapper::dtoToEntity).orElse(null);
				attachment.setUrl(att.getUrl());
				attachment.setAbsolutePath(attachmentPath + att.getAbsolutePath());
				attachmentRepository.save(attachment);
			}
		}
	}
	
	private Boolean checkErr(String fileName) {
		String regex = "^[a-zA-Z0-9._-]$";
		Pattern pattern = Pattern.compile(regex); 
		boolean check = false;
		if(fileName.contains(" ")) {
			check = true;
		} else {
			for(char text: fileName.toCharArray()) {
				if(!pattern.matcher(String.valueOf(text)).matches()) {
					check = true;
					break;
				} 
			}
		}
		return check;
	}
	
	public void saveAts(List<MultipartFile> multipartFiles,String attachmentPath,String moduleType) throws IOException {
		log.info("Entering saveAts()...");
		String[] allowedExtensionImgs = {"jpg","jpeg","png","gif","tiff","pjp","pjpeg","jfif","tif","svg","bmp","svgz","webp","ico","xbm","dib"};
		String[] allowedExtensionVideos = {"ogm","wmv","mpg","webm","ogv","mov","asx","mpeg","mp4","m4v","avi","mov","flv"};
		if (multipartFiles != null && !multipartFiles.isEmpty()) {
			log.debug("---> SIZE: " + multipartFiles.size());
			List<MultipartFile> filterMultipartFiles = multipartFiles.stream().filter(f -> {
				log.debug("---> ContentType: " + f.getContentType());
				log.debug("---> Name: " + f.getName());
				log.debug("---> OriginalFileName: " + f.getOriginalFilename());
				log.debug("---> Size: " + f.getSize());

				return f.getSize() > 0;
			}).collect(Collectors.toList());
			
			if (!filterMultipartFiles.isEmpty()) {
				filterMultipartFiles.forEach(multipartFile -> {
					log.debug("ContentType: " + multipartFile.getContentType());
					log.debug("Name: " + multipartFile.getName());
					log.debug("OriginalFileName: " + multipartFile.getOriginalFilename());
					log.debug("Size: " + multipartFile.getSize());
					List<String> fileType = new ArrayList<>();
					
					if(moduleType.equals(ModuleTypeEnum.VIDEO.val)) {
						fileType = Arrays.asList(allowedExtensionVideos);
						String fileName = multipartFile.getOriginalFilename();
						if(fileName != null && StringUtils.isNotBlank(fileName) && !checkErr(fileName)) {
							String fileTypeImg  = StringUtils.substringAfterLast(fileName, SymbolEnum.DOT.val).toLowerCase();
							Long fileSizeImg = multipartFile.getSize();
							if(fileTypeImg != null && fileType.contains(fileTypeImg) && fileSizeImg <= SizeVideoEnum.SIZE_VIDEO.size) {
								StringBuilder buffer = new StringBuilder();
								buffer.append(moduleType);
								String idFolder = buffer.toString();
								String uploadFolder = attachmentPath + idFolder;
								try {
									UploadedFile uploadedFile = new UploadedFile();
									uploadedFile.setUploadedPath(uploadFolder);
									uploadedFile.setUploadedFileName(multipartFile.getOriginalFilename());
									uploadedFile.setUploadedFileContent(multipartFile.getBytes());
									SpringUploadUtil.uploadFile(uploadedFile);
								} catch (IOException e) {
									log.error("ERROR: ", e);
								}
							}
						}
					}else{
						fileType = Arrays.asList(allowedExtensionImgs);
						String fileName = multipartFile.getOriginalFilename();
						if(fileName != null && StringUtils.isNotBlank(fileName) && !checkErr(fileName)) {
							String fileTypeImg  = StringUtils.substringAfterLast(fileName, SymbolEnum.DOT.val).toLowerCase();
							Long fileSizeImg = multipartFile.getSize();
							Integer sizeImageStandard = SizeImageEnum.CO_CATEGORY_SIZE.sizeImage;
							if(moduleType.equals(ModuleTypeEnum.CO_FOOD_ITEM.val)) {
								sizeImageStandard = SizeImageEnum.CO_FOODITEM_SIZE.sizeImage;
							}
							if(fileTypeImg != null && fileType.contains(fileTypeImg) && fileSizeImg <= sizeImageStandard ) {
								StringBuilder buffer = new StringBuilder();
								buffer.append(moduleType);
								String idFolder = buffer.toString();
								String uploadFolder = attachmentPath + idFolder;
								try {
									UploadedFile uploadedFile = new UploadedFile();
									uploadedFile.setUploadedPath(uploadFolder);
									uploadedFile.setUploadedFileName(multipartFile.getOriginalFilename());
									uploadedFile.setUploadedFileContent(multipartFile.getBytes());
									SpringUploadUtil.uploadFile(uploadedFile);
								} catch (IOException e) {
									log.error("ERROR: ", e);
								}
							}
						}
					}
					
				});
			}
		}
	}
	
	public boolean uploadAttachment(final MultipartFile multipartFile, final String attachmentPath, String moduleType)	throws IOException {
		log.info("Entering saveAttachment()...");
		
		String[] arr = {"jpg","jpeg","png","gif","tiff","pjp","pjpeg","jfif","tif","svg","bmp","svgz","webp","ico","xbm","dib"};
		List<String> fileType = Arrays.asList(arr);
		boolean result = false;
		if (multipartFile != null && multipartFile.getSize() > 0) {
			log.debug("ContentType: " + multipartFile.getContentType());
			log.debug("Name: " + multipartFile.getName());
			log.debug("OriginalFileName: " + multipartFile.getOriginalFilename());
			log.debug("Size: " + multipartFile.getSize());
			StringBuilder absolutePath = new StringBuilder();
			absolutePath.append(attachmentPath).append(moduleType).append(File.separator).append(multipartFile.getOriginalFilename());
			try {
				Path path = Paths.get(absolutePath.toString());
	            if (!Files.exists(path)) {
	            	String fileName = multipartFile.getOriginalFilename();
	            	if(fileName != null && StringUtils.isNotBlank(fileName) && !checkErr(fileName)) {
						String fileTypeImg  = StringUtils.substringAfterLast(fileName, SymbolEnum.DOT.val).toLowerCase();
						Long fileSizeImg = multipartFile.getSize();
						if(fileTypeImg != null && fileType.contains(fileTypeImg) && fileSizeImg <= SizeImageEnum.SIZE.sizeImage  ) {
							StringBuilder buffer = new StringBuilder();
							buffer.append(moduleType);
							String idFolder = buffer.toString();
							String uploadFolder = attachmentPath + idFolder;
							UploadedFile uploadedFile = new UploadedFile();
							uploadedFile.setUploadedPath(uploadFolder);
							uploadedFile.setUploadedFileName(multipartFile.getOriginalFilename());
							uploadedFile.setUploadedFileContent(multipartFile.getBytes());
							SpringUploadUtil.uploadFile(uploadedFile);
						}
					}
	            }
	            result = true;
			} catch (IOException e) {
				result = false;
				log.error(e.getMessage());
			}
		}
		return result;
	}	
	
	public void delAttachment(Long moduleId,String moduleType,String absolutePath,String functionType) {
		log.debug("Entering 'delAttachments' method...");
		Long countAbsolutePath = attachmentRepository.countByAbsolutePath(absolutePath);
		if(moduleId != null) {
			Attachment attachment = attachmentRepository.findByModuleIdAndModuleTypeAndFunctionTypeAndAbsolutePath(moduleId, moduleType,functionType,absolutePath);
			
			if(attachment != null) {
				if(countAbsolutePath == 1) {
					try {
						Files.deleteIfExists(Paths.get(absolutePath));
						attachmentRepository.delete(attachment);
					} catch (IOException e) {
						log.error(e.getMessage());
					}
				}else {
					attachmentRepository.delete(attachment);
				}
			} else {
				if(countAbsolutePath == 0) {
					try {
						Files.deleteIfExists(Paths.get(absolutePath));
					} catch (IOException e) {
						log.error(e.getMessage());
					}
				}
			}
		} else {
			if(countAbsolutePath == 0 || countAbsolutePath != null) {
				try {
					Files.deleteIfExists(Paths.get(absolutePath));
				} catch (IOException e) {
					log.error(e.getMessage());
				}
			}
		}
	}
	
	/*
	 * Lưu thông tin ảnh và video CO_CATEGORY
	 */
	public void savedCoCategoryAttachment(CoCategoryDto coCategoryDto, String attachmentPath, String attachmentContextPath) {
		log.debug("PROCESS FUNCTION: SAVED CO_CATEOGRY ATTACHMENT");
		try {
			if(coCategoryDto.getAvatar() != null)
				savedPhotoAttachment(coCategoryDto.getAvatar(), attachmentPath, attachmentContextPath, coCategoryDto.getId(), ModuleTypeEnum.CO_CATEGORY.val, FunctionTypeEnum.AVATAR.val);
	    	if(coCategoryDto.getPhotos() != null) 
	    		savedMultiPhotoAttachments(coCategoryDto.getPhotos(), attachmentPath, attachmentContextPath, coCategoryDto.getId(), ModuleTypeEnum.CO_CATEGORY.val, FunctionTypeEnum.IMAGES.val);
	    	if(coCategoryDto.getPhotoIntroMenus() != null) 
	    		savedMultiPhotoAttachments(coCategoryDto.getPhotoIntroMenus(), attachmentPath, attachmentContextPath, coCategoryDto.getId(), ModuleTypeEnum.CO_CATEGORY.val, FunctionTypeEnum.AVATAR_ABOUTUS_MENU.val);
	    	if(coCategoryDto.getPhotoIntroRes() != null) 
	    		savedMultiPhotoAttachments(coCategoryDto.getPhotoIntroRes(), attachmentPath, attachmentContextPath, coCategoryDto.getId(), ModuleTypeEnum.CO_CATEGORY.val, FunctionTypeEnum.AVATAR_ABOUTUS_RES.val);
	    	if(coCategoryDto.getVideoIntroMenu() != null)
	    		savedVideoAttachment(coCategoryDto.getVideoIntroMenu(), attachmentPath, attachmentContextPath, coCategoryDto.getId(), ModuleTypeEnum.CO_CATEGORY.val, FunctionTypeEnum.VIDEO_ABOUTUS_MENU.val);
	    	if(coCategoryDto.getVideoIntroRes() != null)
	    		savedVideoAttachment(coCategoryDto.getVideoIntroRes(), attachmentPath, attachmentContextPath, coCategoryDto.getId(), ModuleTypeEnum.CO_CATEGORY.val, FunctionTypeEnum.VIDEO_ABOUTUS_RES.val);
	    	if(coCategoryDto.getSingleCategoryPhoto() != null) 
	    		savedPhotoAttachment(coCategoryDto.getSingleCategoryPhoto(), attachmentPath, attachmentContextPath, coCategoryDto.getId(), ModuleTypeEnum.CO_CATEGORY.val, FunctionTypeEnum.SINGLE_CATEGORY.val);
	    	if(coCategoryDto.getMultiCategoryPhoto() != null) 
	    		savedPhotoAttachment(coCategoryDto.getMultiCategoryPhoto(), attachmentPath, attachmentContextPath, coCategoryDto.getId(), ModuleTypeEnum.CO_CATEGORY.val, FunctionTypeEnum.MULTI_CATEGORY.val);
		} catch (Exception e) {
			log.error("ERROR PROCESS FUNCTION: SAVED CO_CATEOGRY ATTACHMENT EXCEPTION: {}", e);
		}
	}
	
	/*
	 * Function lưu thông tin ảnh CO_FOOD_ITEM và CO_CATEGORY
	 * Upload 1 ảnh
	 */
	private void savedPhotoAttachment(MultipartFile multipartFile, String attachmentPath, String attachmentContextPath, Long moduleId, String moduleType, String functionType) {
		log.debug("PROCESS FUNCTION: SAVED PHOTO ATTACHMENT");
		try {
			String[] arr = {"jpg","jpeg","png","gif","tiff","pjp","pjpeg","jfif","tif","svg","bmp","svgz","webp","ico","xbm","dib"};
			List<String> fileType = Arrays.asList(arr);
			if (multipartFile != null && multipartFile.getSize() > 0) {
				Attachment attachment = getAttachment(moduleId, moduleType, functionType);
				if (!multipartFile.getOriginalFilename().equals(attachment.getFileName())) {
					
					if (StringUtils.isNotBlank(attachment.getAbsolutePath())) {
						Long countByAbsolutePath = attachmentRepository.countByAbsolutePath(attachment.getAbsolutePath());
						if(countByAbsolutePath == 1) {
							if(Paths.get(attachment.getAbsolutePath()) != null) {
								Files.deleteIfExists(Paths.get(attachment.getAbsolutePath()));
							}
							attachmentRepository.delete(attachment);
						}else {
							attachmentRepository.delete(attachment);
						}
					}
					
					String fileName = multipartFile.getOriginalFilename();
					if(fileName != null && StringUtils.isNotBlank(fileName) && !checkErr(fileName)) {
						String fileTypeImg  = StringUtils.substringAfterLast(fileName, SymbolEnum.DOT.val).toLowerCase();
						Long fileSizeImg = multipartFile.getSize();
						Integer sizeImageStandard = SizeImageEnum.CO_CATEGORY_SIZE.sizeImage;
						if(moduleType.equals(ModuleTypeEnum.CO_FOOD_ITEM.val)) {
							sizeImageStandard = SizeImageEnum.CO_FOODITEM_SIZE.sizeImage;
						}
						if(fileTypeImg != null && fileType.contains(fileTypeImg) && fileSizeImg <= sizeImageStandard) {
							StringBuilder buffer = new StringBuilder();
							buffer.append(moduleType).append(File.separator).append(functionType).append(File.separator).append(moduleId);
							String idFolder = buffer.toString();
							String uploadFolder = attachmentPath + idFolder;
							String absolutePath = uploadFolder + File.separator + multipartFile.getOriginalFilename();
							String url = attachmentContextPath + idFolder + File.separator + multipartFile.getOriginalFilename();

							attachment.setModuleType(moduleType);
							attachment.setModuleId(moduleId);
							attachment.setFunctionType(functionType);
							attachment.setFileName(multipartFile.getOriginalFilename());
							attachment.setFileType(StringUtils.substringAfterLast(multipartFile.getOriginalFilename(), SymbolEnum.DOT.val));
							attachment.setAbsolutePath(absolutePath);
							attachment.setUrl(url);
							attachment = attachmentRepository.save(attachment);

							if (attachment.getId() != null) {
								UploadedFile uploadedFile = new UploadedFile();
								uploadedFile.setUploadedPath(uploadFolder);
								uploadedFile.setUploadedFileName(multipartFile.getOriginalFilename());
								uploadedFile.setUploadedFileContent(multipartFile.getBytes());
								SpringUploadUtil.uploadFile(uploadedFile);
							}
						}
					}
				}
			}
		} catch (Exception e) {
			log.error("ERROR PROCESS FUNCTION: SAVED PHOTO ATTACHMENT EXCEPTION: {}", e);
		}
		
	}	
	
	/*
	 * Function lưu thông tin ảnh CO_FOOD_ITEM và CO_CATEGORY
	 * Upload nhiều ảnh
	 */
	private void savedMultiPhotoAttachments(List<MultipartFile> multipartFiles, String attachmentPath, String attachmentContextPath, Long moduleId, String moduleType, String functionType) {
		log.debug("PROCESS FUNCTION: SAVED MULTI PHOTO ATTACHMENT");
		try {
			String[] arr = {"jpg","jpeg","png","gif","tiff","pjp","pjpeg","jfif","tif","svg","bmp","svgz","webp","ico","xbm","dib"};
			List<String> fileType = Arrays.asList(arr);
			if (multipartFiles != null && !multipartFiles.isEmpty()) {
				List<Attachment> existingAttachments = getAttachments(moduleId, moduleType, functionType);
				
				List<MultipartFile> filterMultipartFiles = multipartFiles.stream().filter(f -> {
					return f.getSize() > 0;
				}).collect(Collectors.toList());
				
				if (!filterMultipartFiles.isEmpty()) {
					filterMultipartFiles.removeIf(f -> {
						if (existingAttachments == null || existingAttachments.isEmpty()) {
							return false;
						} else {
							return existingAttachments.stream().anyMatch(attachment -> f.getOriginalFilename().equals(attachment.getFileName()));						
						}
					});
					
					filterMultipartFiles.forEach(multipartFile -> {
						
						String fileName = multipartFile.getOriginalFilename();
						if(fileName != null && StringUtils.isNotBlank(fileName) && !checkErr(fileName)) {
							String fileTypeImg  = StringUtils.substringAfterLast(fileName, SymbolEnum.DOT.val).toLowerCase();
							Long fileSizeImg = multipartFile.getSize();
							if(fileTypeImg != null && fileType.contains(fileTypeImg) && fileSizeImg <= SizeImageEnum.SIZE.sizeImage  ) {
								StringBuilder buffer = new StringBuilder();
								buffer.append(moduleType).append(File.separator).append(functionType).append(File.separator).append(moduleId);
								String idFolder = buffer.toString();
								String uploadFolder = attachmentPath + idFolder;
								String absolutePath = uploadFolder + File.separator + multipartFile.getOriginalFilename();
								String url = attachmentContextPath + idFolder + File.separator + multipartFile.getOriginalFilename();
								
								Attachment attachment = new Attachment();
								attachment.setModuleType(moduleType);
								attachment.setModuleId(moduleId);
								attachment.setFunctionType(functionType);
								attachment.setFileName(multipartFile.getOriginalFilename());
								attachment.setFileType(StringUtils.substringAfterLast(multipartFile.getOriginalFilename(), SymbolEnum.DOT.val));
								attachment.setAbsolutePath(absolutePath);
								attachment.setUrl(url);
								attachment = attachmentRepository.save(attachment);

								if (attachment.getId() != null) {
									try {
										UploadedFile uploadedFile = new UploadedFile();
										uploadedFile.setUploadedPath(uploadFolder);
										uploadedFile.setUploadedFileName(multipartFile.getOriginalFilename());
										uploadedFile.setUploadedFileContent(multipartFile.getBytes());
										SpringUploadUtil.uploadFile(uploadedFile);
									} catch (IOException e) {
										log.error("ERROR: PROCESS FUNCTION: SAVED MULTI PHOTO ATTACHMENT EXCEPTION: {}", e);
									}
								}
							}
						}
						
					});
				}
			}
		} catch (Exception e) {
			log.error("ERROR PROCESS FUNCTION: SAVED MULTI PHOTO ATTACHMENT EXCEPTION: {}", e);
		}
	}
	
	/*
	 * Function lưu thông tin video CO_FOOD_ITEM và CO_CATEGORY
	 */
	private void savedVideoAttachment(final MultipartFile multipartFile, final String attachmentPath, final String attachmentContextPath, final Long moduleId, final String moduleType, final String functionType) {
		log.debug("PROCESS FUNCTION: SAVED VIDEO ATTACHMENT");
		try {
			String[] arr = {"ogm","wmv","mpg","webm","ogv","mov","asx","mpeg","mp4","m4v","avi","mov","flv"};
			List<String> fileType = Arrays.asList(arr);
			if (multipartFile != null && multipartFile.getSize() > 0) {
				Attachment attachment = getAttachment(moduleId, moduleType, functionType);
				if (!multipartFile.getOriginalFilename().equals(attachment.getFileName())) {
					if (StringUtils.isNotBlank(attachment.getAbsolutePath())) {
						Long countByAbsolutePath = attachmentRepository.countByAbsolutePath(attachment.getAbsolutePath());
						if(countByAbsolutePath == 1) {
							if(Paths.get(attachment.getAbsolutePath()) != null) {
								Files.deleteIfExists(Paths.get(attachment.getAbsolutePath()));
							}
							attachmentRepository.delete(attachment);
						}else {
							attachmentRepository.delete(attachment);
						}
					}
					
					String fileName = multipartFile.getOriginalFilename();
					if(fileName != null && StringUtils.isNotBlank(fileName) && !checkErr(fileName)) {
						String fileTypeImg  = StringUtils.substringAfterLast(fileName, SymbolEnum.DOT.val).toLowerCase();
						Long fileSizeImg = multipartFile.getSize();
						if(fileTypeImg != null && fileType.contains(fileTypeImg) && fileSizeImg <= SizeVideoEnum.SIZE_VIDEO.size) {
							StringBuilder buffer = new StringBuilder();
							buffer.append(moduleType).append(File.separator).append(functionType).append(File.separator).append(moduleId);
							String idFolder = buffer.toString();
							String uploadFolder = attachmentPath + idFolder;
							String absolutePath = uploadFolder + File.separator + multipartFile.getOriginalFilename();
							String url = attachmentContextPath + idFolder + File.separator + multipartFile.getOriginalFilename();

							attachment.setModuleType(moduleType);
							attachment.setModuleId(moduleId);
							attachment.setFunctionType(functionType);
							attachment.setFileName(multipartFile.getOriginalFilename());
							attachment.setFileType(StringUtils.substringAfterLast(multipartFile.getOriginalFilename(), SymbolEnum.DOT.val));
							attachment.setAbsolutePath(absolutePath);
							attachment.setUrl(url);
							attachment = attachmentRepository.save(attachment);

							if (attachment.getId() != null) {
								UploadedFile uploadedFile = new UploadedFile();
								uploadedFile.setUploadedPath(uploadFolder);
								uploadedFile.setUploadedFileName(multipartFile.getOriginalFilename());
								uploadedFile.setUploadedFileContent(multipartFile.getBytes());
								SpringUploadUtil.uploadFile(uploadedFile);
							}
						}
					}
				}
			}
		} catch (Exception e) {
			log.error("ERROR PROCESS FUNCTION: SAVED VIDEO ATTACHMENT EXCEPTION: {}", e);
		}
	}	
	
}