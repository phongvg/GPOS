package com.gg.gpos.menu.manager;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import javax.transaction.Transactional;

import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;

import com.gg.gpos.common.constant.ModuleTypeEnum;
import com.gg.gpos.common.constant.StatusEnum;
import com.gg.gpos.common.constant.SymbolEnum;
import com.gg.gpos.common.constant.TypeRestaurantDataEditEnum;
import com.gg.gpos.common.json.ResponseData;
import com.gg.gpos.common.util.FancyTree;
import com.gg.gpos.menu.dto.SoCategoryDto;
import com.gg.gpos.menu.dto.SoDto;
import com.gg.gpos.menu.entity.CatalogApplyToRestaurant;
import com.gg.gpos.menu.entity.CatalogDataEdit;
import com.gg.gpos.menu.entity.Co;
import com.gg.gpos.menu.entity.CoCategory;
import com.gg.gpos.menu.entity.CoFoodItem;
import com.gg.gpos.menu.entity.FoodGroup;
import com.gg.gpos.menu.entity.FoodGroupItem;
import com.gg.gpos.menu.entity.FoodItem;
import com.gg.gpos.menu.entity.RestaurantDataEdit;
import com.gg.gpos.menu.entity.So;
import com.gg.gpos.menu.entity.SoCategory;
import com.gg.gpos.menu.entity.SoCategoryFoodGroup;
import com.gg.gpos.menu.mapper.SoMapper;
import com.gg.gpos.menu.repository.CatalogApplyToRestaurantRepository;
import com.gg.gpos.menu.repository.CatalogDataEditRepository;
import com.gg.gpos.menu.repository.CoCategoryRepository;
import com.gg.gpos.menu.repository.CoFoodGroupDisplayRepository;
import com.gg.gpos.menu.repository.CoFoodItemModifierRepository;
import com.gg.gpos.menu.repository.CoFoodItemRepository;
import com.gg.gpos.menu.repository.CoRepository;
import com.gg.gpos.menu.repository.FoodGroupItemRepository;
import com.gg.gpos.menu.repository.FoodGroupRepository;
import com.gg.gpos.menu.repository.RelatedFoodItemRepository;
import com.gg.gpos.menu.repository.RestaurantDataEditRepository;
import com.gg.gpos.menu.repository.SoCategoryFoodGroupRepository;
import com.gg.gpos.menu.repository.SoCategoryRepository;
import com.gg.gpos.menu.repository.SoRepository;
import com.gg.gpos.menu.repository.ToppingFoodItemRepository;
import com.gg.gpos.menu.specification.SoSpecification;
import com.gg.gpos.reference.entity.Attachment;
import com.gg.gpos.reference.repository.AttachmentRepository;

import lombok.extern.slf4j.Slf4j;

/**
 * Generated by Speed Generator
 * 
 * @author <a href="mailto:ngtrungkien@gmail.com">Kien Nguyen</a>
 */
@Slf4j
@Service
@Transactional
public class SoManager {
	@Autowired
	private SoRepository soRepository;
	@Autowired
	private SoMapper soMapper;
	@Autowired
	private SoCategoryRepository soCategoryRepository;
	@Autowired
	private SoCategoryFoodGroupRepository soCategoryFoodGroupRepository;
	@Autowired
	private FoodGroupRepository foodGroupRepository;
	@Autowired
	private FoodGroupItemRepository foodGroupItemRepository;
	@Autowired
	private CoFoodItemRepository coFoodItemRepository;
	@Autowired
	private SoSpecification soSpecification;
	@Autowired
	private RelatedFoodItemRepository relatedFoodItemRepository;
	@Autowired
	private CoRepository coRepository;
	@Autowired
	private CoCategoryRepository coCategoryRepository;
	@Autowired
	private CoFoodGroupDisplayRepository coFoodGroupDisplayRepository;
	@Autowired
	private ToppingFoodItemRepository toppingFoodItemRepository;
	@Autowired
	private CatalogApplyToRestaurantRepository catalogApplyToRestaurantRepository;
	@Autowired
	private RestaurantDataEditRepository restaurantDataEditRepository;
	@Autowired
	private CatalogDataEditRepository catalogDataEditRepository;
	@Autowired
	private AttachmentRepository attachmentRepository;
	@Autowired
	private CoFoodItemModifierRepository coFoodItemModifierRepository;
	/*
	 * LẤY THÔNG TIN CHI TIẾT SO
	 */
	public SoDto get(Long id) {
		log.info("PROCESS: GET SO BY ID, SO_ID: {}", id);
		return soRepository.findById(id).map(soMapper::entityToDto).orElse(null);
	}
	
	public List<SoDto> gets() {
		return soRepository.findAll().stream().map(soMapper::entityToDto).collect(Collectors.toList());
	}
	
	/*
	 * TÌM KIẾM DANH SÁCH CÁC CATALOG SO CÓ TRẠNG THÁI TRUE
	 */
	public List<SoDto> getByStatusTrue() {
		log.info("PROCESS: GET SO BY STATUS IS TRUE");
		return soRepository.findByStatusIsTrue().stream().map(soMapper::entityToDto).collect(Collectors.toList());
	}
	
	public SoDto saveAfterChangeCatalog(Long id) {
		log.debug("PROCESS FUNCTION: SAVE SO_MENU AFTER CHANGE CATALOG, SO_MENU_ID: {}", id);
		So so = soRepository.findById(id).get();
		if(so != null) {
			so.setModifiedDate(LocalDateTime.now());
			return Optional.ofNullable(soRepository.save(so)).map(soMapper::entityToDto).orElse(null);
		} else {
			return null;
		}
	}
	
	public void saveAfterChangeCatalogs(Set<Long> soIds) {
		log.info("Entering 'SoDto saveAfterChangeCatalog(Long id)' method...");
		soIds.stream().forEach(id ->{
			So so = soRepository.findById(id).get();
			if(so != null) {
				so.setModifiedDate(LocalDateTime.now());
				soRepository.save(so);
			}
		});
	}
	
	public List<SoDto> getByStatusAndSoCategories(){
		log.debug("Entering 'getByStatusAndSoCategories' method...");
		
		List<So> source = soRepository.findStatusAndSoCategories();
		return source.stream().map(so -> {
			SoDto soDto = new SoDto();
			BeanUtils.copyProperties(so, soDto);
			return soDto;
		}).collect(Collectors.toList());
	}
	
	/*
	 * LƯU THÔNG TIN CATALOG SO
	 */
	public SoDto save(SoDto soDto) {
		log.info("PRCESS: SAVE CATALOG SO, SO: {}", soDto);
				
		So so = Optional.ofNullable(soDto).map(soMapper::dtoToEntity).orElse(null);
		if (so != null) {
			// kiểm tra trạng thái của SO. Nếu trạng thái OFF thì xóa dữ liệu SO và CO tương ứng
			if(so.getId() != null && !so.isStatus()) {
				offCo(so);
				off(so);
			}
			return Optional.ofNullable(soRepository.save(so)).map(soMapper::entityToDto).orElse(null);
		} else {
			return null;
		}
	}
	
	/*
	 * Hiển thị danh sách SO
	 */
	public Page<SoDto> gets(SoDto criteria){
		log.info("PROCESS: GETS SO, SO: {}", criteria);
		Page<So> page = soRepository.findAll(soSpecification.filter(criteria), PageRequest.of(criteria.getPage(), criteria.getSize(), Sort.by(Sort.Direction.DESC, "modifiedDate")));
		return new PageImpl<>(page.getContent().stream().map(soMapper::entityToDto).collect(Collectors.toList()), PageRequest.of(criteria.getPage(), criteria.getSize()), page.getTotalElements());
	}
	
	public boolean isApplied(Long id) {
		So so = new So();
		so.setId(id);
		List<SoCategory> list = soCategoryRepository.findBySoAndRestaurantCodeIsNotNull(so); 
		return (list != null && !list.isEmpty());
	}
	
	public void delete(Long id) {
		log.debug("Entering 'delete' method...");
		So so = new So();
		so.setId(id);
		soRepository.delete(so);
	}
	
	public ResponseData checkToOff(Long soId) {
		log.info("Entering 'checkToOff(soId)' method...");
		
		ResponseData res = new ResponseData();
		List<Integer> resCodes = soCategoryRepository.findRestaurantCodes(soId);
		if (resCodes != null && !resCodes.isEmpty()) {
			res.setData(resCodes);
			res.setResult(true);
			res.setSize(resCodes.size());
		} else {
			res.setResult(false);
		}
		return res;
	}
	
	
	/*
	 * Set lại trạng thái của danh mục CO theo trạng thái của danh mục SO
	 */
	private void offCo(So so) {
		log.info("PROCESS: OFF CATALOG CO AFTER OFF SO, SO: {}", so);
		List<Co> cos = coRepository.findBySoId(so.getId());
		if(cos != null && !cos.isEmpty()) {
			cos.stream().forEach(co ->{
				if(so.isStatus()) {
					co.setStatus(true);
					coRepository.save(co);
				}else {
					co.setStatus(false);
					coRepository.save(co);
				}
			});
		}
	}
	
	/*
	 * Xóa dữ liệu của SO và CO tương ứng
	 */
	private void off(final So so) {
		log.info("PROCESS: OFF AND DELETE DATA SO_CO, SO_ID: {}", so.getId());
		
		// LẤY DANH SÁCH NHÀ HÀNG ĐANG ĐƯỢC ÁP DỤNG DANH MỤC SO NÀY ĐỂ XÓA DỮ LIỆU SO VÀ CO
		List<CatalogApplyToRestaurant> applyToRestaurants = catalogApplyToRestaurantRepository.findBySoId(so.getId());
		if(applyToRestaurants != null && !applyToRestaurants.isEmpty()) {
			applyToRestaurants.stream().forEach(item -> {
				Integer resCode = item.getRestaurantCode();
				Set<Long> soCategoryIds = new HashSet<>();
				Set<FoodGroup> deletedFoodGroup = new HashSet<>();
				Set<FoodGroup> deletedFoodGroupHasParent = new HashSet<>();
				List<SoCategoryFoodGroup> soCategoryFoodGroups = soCategoryFoodGroupRepository.findByRestaurantCode(resCode);
				if (soCategoryFoodGroups != null && !soCategoryFoodGroups.isEmpty()) {
					soCategoryFoodGroups.stream().forEach(scfg -> {
						// pick so category for deletion
						soCategoryIds.add(scfg.getSoCategory().getId());
						// pick food group for deletion
						if(scfg.getFoodGroup().getParent() != null) {
							deletedFoodGroupHasParent.add(scfg.getFoodGroup());
						} else {
							deletedFoodGroup.add(scfg.getFoodGroup());
						}
						// delete so category food group
						soCategoryFoodGroupRepository.delete(scfg);
					});
				}
				// delete food-group-item and food-group
				if(!deletedFoodGroupHasParent.isEmpty()) {
					deletedFoodGroupHasParent.stream().forEach(fg -> {
						foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(fg, resCode);
						delAttachment(fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
						foodGroupRepository.delete(fg);
					});
				}
				// delete food-group-item and food-group
				if(!deletedFoodGroup.isEmpty()) {
					deletedFoodGroup.stream().forEach(fg -> {
						foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(fg, resCode);
						delAttachment(fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
						foodGroupRepository.delete(fg);
					});
				}
				// delete co_fooditem
				List<CoFoodItem> coFoodItems = coFoodItemRepository.findByRestaurantCode(resCode);
				if (coFoodItems != null && !coFoodItems.isEmpty()) {
					coFoodItems.stream().forEach(coFoodItem ->{
						coFoodItemModifierRepository.deleteByCoFoodItem(coFoodItem);
						relatedFoodItemRepository.deleteByCoFoodItem(coFoodItem);
						toppingFoodItemRepository.deleteByCoFoodItem(coFoodItem);
						delAttachment(coFoodItem.getId(), ModuleTypeEnum.CO_FOOD_ITEM.val);
						coFoodItemRepository.delete(coFoodItem);
					});
				}
				// delete cocategory
				List<CoCategory> coCategories = coCategoryRepository.findByRestaurantCode(resCode);
				if (coCategories != null && !coCategories.isEmpty()) {
					coCategories.stream().forEach(coCategory ->{
						coFoodGroupDisplayRepository.deleteByCoCategory(coCategory);
						delAttachment(coCategory.getId(), ModuleTypeEnum.CO_CATEGORY.val);
						coCategoryRepository.delete(coCategory);
					});
				}
				// delete so category
				soCategoryRepository.deleteByRestaurantCode(resCode);
				item.setCoId(null);
				item.setSoId(null);
				catalogApplyToRestaurantRepository.save(item);
			});
		}
	}
	
	// delete attachment
	private void delAttachment(Long moduleId,String moduleType) {
		log.info("Entering 'delAttachment(Long moduleId,String moduleType)' method...");
		log.debug("Params: moduleId: " + moduleId + ", moduleType: " + moduleType);
		List<Attachment> attachments = attachmentRepository.findByModuleIdAndModuleType(moduleId, moduleType);
		if(attachments != null && !attachments.isEmpty()) {
			attachments.stream().forEach(attachment ->{
				attachment.setModuleId(null);
				attachment.setFunctionType(null);
				attachment.setModuleType(ModuleTypeEnum.DEL_ATTACHMENT.val);
				attachment.setRestaurantCode(null);
				attachment.setSyncStatus(null);
				attachmentRepository.save(attachment);
			});
		}
	}

	//delete data in restaurant
	private void delRestaurantSoData(Integer resCode, boolean isOverride) {
		log.info("Entering 'delRestaurantSoData(Integer resCode, boolean isOverride)' method...");
		
		Set<Long> soCategoryIds = new HashSet<>();
		List<SoCategoryFoodGroup> soCategoryFoodGroups = null;
		List<CoFoodItem> coFoodItems = null;
		Set<FoodGroup> deletedFoodGroup = new HashSet<>();
		Set<FoodGroup> deletedFoodGroupHasParent = new HashSet<>();
		List<CoCategory> coCategories = null;
		
		if (isOverride) {
			soCategoryFoodGroups = soCategoryFoodGroupRepository.findByRestaurantCode(resCode);
			coFoodItems = coFoodItemRepository.findByRestaurantCode(resCode);
			coCategories = coCategoryRepository.findByRestaurantCode(resCode);
			
		} else {
			soCategoryFoodGroups = soCategoryFoodGroupRepository.findBySoIdIsNotNullAndRestaurantCode(resCode);
			coFoodItems = coFoodItemRepository.findBySoIdIsNullAndRestaurantCode(resCode);
		}
		if (soCategoryFoodGroups != null && !soCategoryFoodGroups.isEmpty()) {
			soCategoryFoodGroups.stream().forEach(scfg -> {
				// pick so category for deletion
				soCategoryIds.add(scfg.getSoCategory().getId());
				// pick food group for deletion
				if(scfg.getFoodGroup().getParent() != null) {
					deletedFoodGroupHasParent.add(scfg.getFoodGroup());
				} else {
					deletedFoodGroup.add(scfg.getFoodGroup());
				}
				// delete so category food group
				soCategoryFoodGroupRepository.delete(scfg);
			});
		}
		// delete food-group-item and food-group
		if(!deletedFoodGroupHasParent.isEmpty()) {
			deletedFoodGroupHasParent.stream().forEach(fg -> {
				foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(fg, resCode);
				delAttachment(fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
				foodGroupRepository.delete(fg);
			});
		}
		// delete food-group-item and food-group
		if(!deletedFoodGroup.isEmpty()) {
			deletedFoodGroup.stream().forEach(fg -> {
				foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(fg, resCode);
				delAttachment(fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
				foodGroupRepository.delete(fg);
			});
		}
		// delete co fooditem
		if (coFoodItems != null && !coFoodItems.isEmpty()) {
			coFoodItems.stream().forEach(coFoodItem ->{
				coFoodItemModifierRepository.deleteByCoFoodItem(coFoodItem);
				relatedFoodItemRepository.deleteByCoFoodItem(coFoodItem);
				toppingFoodItemRepository.deleteByCoFoodItem(coFoodItem);
				delAttachment(coFoodItem.getId(), ModuleTypeEnum.CO_FOOD_ITEM.val);
				coFoodItemRepository.delete(coFoodItem);
			});
		}
		// delete coCategory
		if (coCategories != null && !coCategories.isEmpty()) {
			coCategories.stream().forEach(coCategory ->{
				coFoodGroupDisplayRepository.deleteByCoCategory(coCategory);
				delAttachment(coCategory.getId(), ModuleTypeEnum.CO_CATEGORY.val);
				coCategoryRepository.delete(coCategory);
			});
		}
		// delete so category
		if (!soCategoryIds.isEmpty()) {
			soCategoryIds.stream().forEach(soCategoryId ->{
				List<CoCategory> categories = coCategoryRepository.findBySoCategoryIdAndResCode(soCategoryId,resCode);
				if(categories != null && !categories.isEmpty()) {
					categories.stream().forEach(coCategory ->{
						coFoodGroupDisplayRepository.deleteByCoCategory(coCategory);
						delAttachment(coCategory.getId(), ModuleTypeEnum.CO_CATEGORY.val);
						coCategoryRepository.delete(coCategory);
					});
				}
				// delete so-category
				soCategoryRepository.deleteById(soCategoryId);
			});
		}
		// delete so category if scfg.getSoCategory().getId() is null
		if (isOverride) {
			soCategoryRepository.deleteByRestaurantCode(resCode);
		} else {
			soCategoryRepository.deleteByRestaurantCodeAndSoIsNotNull(resCode);
		}
	}
	
	//save catalogId apply to res
	private void saveCatalogApply(Integer resCode, Long soId,boolean isOverride) {
		CatalogApplyToRestaurant applyToRestaurant = catalogApplyToRestaurantRepository.findByRestaurantCode(resCode);
		if(applyToRestaurant == null) {
			applyToRestaurant = new CatalogApplyToRestaurant();
			applyToRestaurant.setSoId(soId);
		} else {
			if(soId == null) {
				applyToRestaurant.setCoId(null);
				applyToRestaurant.setSoId(null);
			} else if(applyToRestaurant.getSoId() != null && !applyToRestaurant.getSoId().equals(soId)) {
				applyToRestaurant.setCoId(null);
				applyToRestaurant.setSoId(soId);
			} else {
				if(isOverride) {
					applyToRestaurant.setCoId(null);
				}
				applyToRestaurant.setSoId(soId);
			}
		}
		applyToRestaurant.setRestaurantCode(resCode);
		catalogApplyToRestaurantRepository.save(applyToRestaurant);
	}
	
	//delete data catalogDataEdit
	private void delCatalogData(Long soId) {
		catalogDataEditRepository.deleteByCatalogIdAndType(soId, TypeRestaurantDataEditEnum.SO_CATEGORY.val);
		catalogDataEditRepository.deleteByCatalogIdAndType(soId, TypeRestaurantDataEditEnum.DELETE_SO_CATEGORY.val);
	}
	
	// apply data from catalog to res before sync data to restaurant
	public void syncFromToServerRes(SoDto soDto,boolean isOverride,Integer toResCode,List<Integer> rCodeExistings,String username) {
    	log.info("Entering 'syncFromToServerRes(CoDto coDto,boolean isOverride,Integer toResCode,List<Integer> rCodeExistings)' method...");
    	Long soId = soDto.getId();
        So so = Optional.ofNullable(soDto).map(soMapper::dtoToEntity).orElse(null);
        
        if(isOverride) {
        	///saveSoCategory(So so,Integer resCode, boolean isOverride,boolean isCopyToRes,String username)
			saveSoCategory(so, toResCode, true, false, username);
			saveCatalogApply(toResCode,soId,true);
        } else {
    		if(rCodeExistings != null && !rCodeExistings.isEmpty()) {
    			if(rCodeExistings.contains(toResCode)) {
    				saveSoCategory(so, toResCode, false, false, username);	
    			} else {
    				saveSoCategory(so, toResCode, true, false, username);	
    			}
    			//save catalogApplyToRes
    			saveCatalogApply(toResCode,soId,false);
    		} else {
    			saveSoCategory(so, toResCode, true, false, username);
				saveCatalogApply(toResCode,soId,false);
    		}
        }
     // set foodGroup changed = 0 after sync
		updateFoodGroupChanged(soId);
		delCatalogData(soId);
	}
		
	public void deleteDataIfResUncheck(List<Integer> rCodeExistings, List<String> resCodeSelected,Long catalogId) {
		// delete data if resCode uncheck
        if(resCodeSelected != null && !resCodeSelected.isEmpty() && rCodeExistings != null && !rCodeExistings.isEmpty()) {
        	rCodeExistings.stream().forEach(rCode ->{
        		if(!resCodeSelected.contains(rCode.toString())) {
        			delRestaurantSoData(rCode, true); 
					//set null so_id in catalogApplyToRes
					saveCatalogApply(rCode, null,true);
					//delete restaurantDataEdit
					restaurantDataEditRepository.deleteByRestaurantCode(rCode);
        		}
        	});
        }
	}
	
	//sync data from catalog to restaurants
	public void applyToRes(final String username, final SoDto soDto) {
		log.info("Entering 'applyToRes(username, so)' method...");
		log.debug("Params: soId: "+soDto.getId()+", toResCodes: " + soDto.getSelectedRestaurantCodes());
		
		
		Long soId = soDto.getId();
		String selectedRestaurantCodes = soDto.getSelectedRestaurantCodes();
		boolean isOverride = soDto.getOverride();
		// find Restaurants belong to SO
		List<CatalogApplyToRestaurant> applyToRestaurants = catalogApplyToRestaurantRepository.findBySoId(soId);
		List<Integer> resCodes = applyToRestaurants.stream().map(r -> r.getRestaurantCode()).collect(Collectors.toList());
		if (soId != null && !StringUtils.isEmpty(selectedRestaurantCodes)) {
	    	So so = new So();
	    	so.setId(soId);

			List<String> toResCodes = StringUtils.commaDelimitedListToSet(soDto.getSelectedRestaurantCodes()).stream().filter(item -> !item.contains(SymbolEnum.UNDERSCORE.val)).collect(Collectors.toList());
			// filter removed restaurant codes
//			if(resCodes != null && !resCodes.isEmpty()) {
//				List<Integer> removedRestaurantCodes = resCodes.stream().filter(rc -> !toResCodes.contains(rc.toString())).collect(Collectors.toList());
//				
//				// delete data of removed restaurant
//				removedRestaurantCodes.stream().forEach(resCode -> {
//					delRestaurantSoData(resCode, isOverride); 
//					//set null so_id in catalogApplyToRes
//					saveCatalogApply(resCode, null,true);
//					//delete restaurantDataEdit
//					restaurantDataEditRepository.deleteByRestaurantCode(resCode);
//				});
//			}
			 
	    	
			if(toResCodes != null && !toResCodes.isEmpty()) {
				if(isOverride) {
					toResCodes.stream().forEach(toResCode ->{
						//saveSoCategory(So so,Integer resCode, boolean isOverride,boolean isCopyToRes,String username)
						saveSoCategory(so, Integer.parseInt(toResCode), true, false, username);
						saveCatalogApply(Integer.parseInt(toResCode),soId,true);
					});
				} else {
					if(resCodes != null && !resCodes.isEmpty()) {
						toResCodes.stream().forEach(toResCode ->{
							if(resCodes.contains(Integer.parseInt(toResCode))) {
								saveSoCategory(so, Integer.parseInt(toResCode), false, false, username);
							} else {
								saveSoCategory(so, Integer.parseInt(toResCode), true, false, username);
							}
							saveCatalogApply(Integer.parseInt(toResCode),soId,false);
						});
					} else {
						toResCodes.stream().forEach(toResCode ->{
							saveSoCategory(so, Integer.parseInt(toResCode), true, false, username);
							saveCatalogApply(Integer.parseInt(toResCode),soId,false);
						});
					}
				}
			}
		}
		// set foodGroup changed = 0 after sync
		updateFoodGroupChanged(soId);
		delCatalogData(soId);
	}
	
	// set foodGroup changed = 0 after sync
	private void updateFoodGroupChanged(Long soId) {
		List<Long> soCateIds = catalogDataEditRepository.findByTypeAndCatalogId(TypeRestaurantDataEditEnum.SO_CATEGORY.val,soId).stream().map(i -> Long.parseLong(i.getValue())).collect(Collectors.toList());
		if(soCateIds != null && !soCateIds.isEmpty()) {
			List<SoCategory> soCategories = soCategoryRepository.findByIdIn(soCateIds);
			if(soCategories != null && !soCategories.isEmpty()) {
				soCategories.stream().forEach(item ->{
					List<FoodGroup> foodGroups = foodGroupRepository.findByResCodeIsNullAndScIdAndChanged(item.getId(), StatusEnum.ACTIVE.status);
					if(foodGroups != null && !foodGroups.isEmpty()) {
						foodGroups.stream().forEach(fg ->{
							fg.setChanged(StatusEnum.INACTIVE.status);
							foodGroupRepository.save(fg);
						});
					}
				});
			}
		}
	}
	
	//delete SoCategory
	private void deleteSoCategory(SoCategory soCategory, boolean isDelSC) {
		log.debug("Entering 'deleteCategory(SoCategory soCategory)' method...");
		Set<FoodGroup> deletedFoodGroup = new HashSet<>();
		Set<FoodGroup> deletedFoodGroupHasParent = new HashSet<>();
		Integer resCode = soCategory.getRestaurantCode();
		
		// delete so-category-food-group
		List<SoCategoryFoodGroup> soCategoryFoodGroups = soCategoryFoodGroupRepository.findBySoCategoryAndRestaurantCode(soCategory.getId(), resCode);
		if(soCategoryFoodGroups != null && !soCategoryFoodGroups.isEmpty()) {
			soCategoryFoodGroups.stream().forEach(scfg ->{
				if(scfg.getFoodGroup().getParent() != null) {
					deletedFoodGroupHasParent.add(scfg.getFoodGroup());
				} else {
					deletedFoodGroup.add(scfg.getFoodGroup());
				}
				if(scfg.getFoodGroup().getChanged() == null || !scfg.getFoodGroup().getChanged().equals(StatusEnum.ACTIVE.status)) {
					soCategoryFoodGroupRepository.delete(scfg);
				}
			});
		}
		// delete food-group-item and food-group
		if(!deletedFoodGroupHasParent.isEmpty()) {
			deletedFoodGroupHasParent.stream().forEach(fg -> {
				if(fg.getChanged() == null || !fg.getChanged().equals(StatusEnum.ACTIVE.status)) {
					foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(fg, resCode);
					delAttachment(fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
					foodGroupRepository.delete(fg);
				}
			});
		}
		// delete food-group-item and food-group
		if(!deletedFoodGroup.isEmpty()) {
			deletedFoodGroup.stream().forEach(fg -> {
				if(fg.getChanged() == null || !fg.getChanged().equals(StatusEnum.ACTIVE.status)) {
					foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(fg, resCode);
					delAttachment(fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
					foodGroupRepository.delete(fg);
				}
				
			});
		}
		// delete SoCategory
		if(isDelSC) {
			soCategoryRepository.delete(soCategory);
		}
	}
	
	private void deleteCoCategory(CoCategory coCategory) {
		log.debug("Entering 'deleteCoCategory(CoCategory coCategory)' method...");
		coFoodGroupDisplayRepository.deleteByCoCategory(coCategory);
		delAttachment(coCategory.getId(), ModuleTypeEnum.CO_CATEGORY.val);
		coCategoryRepository.delete(coCategory);
	}
	
	//clone SoCategory
	private void saveSoCategory(So so,Integer resCode, boolean isOverride,boolean isCopyToRes,String username) {
		log.debug("Entering 'saveSoCategory(So so,Integer resCode, boolean isOverride,boolean isCopyToRes,String username)' method...");
		
		List<SoCategory> soCategories = new ArrayList<>();
		Long soId = so.getId();
		if(isOverride) {
			//prepare data
			soCategories = soCategoryRepository.findBySoAndRestaurantCodeIsNull(so);
			//delete data before sync data
			delRestaurantSoData(resCode, true);
			// delete restaurantDataEdit before sync data
			restaurantDataEditRepository.deleteByRestaurantCode(resCode);
		} else if(isCopyToRes) {
			//prepare data
			List<RestaurantDataEdit> scDatas = restaurantDataEditRepository.findByRestaurantCodeAndType(resCode, TypeRestaurantDataEditEnum.SO_CATEGORY.val);
			if(scDatas != null && !scDatas.isEmpty()) {
				List<Long> soCategoryIds = scDatas.stream().map(sc -> Long.parseLong(sc.getValue())).collect(Collectors.toList());
				soCategories = soCategoryRepository.findByIdIn(soCategoryIds);
			}
		} else {
			//prepare data
			List<CatalogDataEdit> scDatas = catalogDataEditRepository.findByTypeAndCatalogId(TypeRestaurantDataEditEnum.SO_CATEGORY.val,soId);
			if(scDatas != null && !scDatas.isEmpty()) {
				List<Long> soCategoryIds = scDatas.stream().map(sc -> Long.parseLong(sc.getValue())).collect(Collectors.toList());
				soCategories = soCategoryRepository.findByIdIn(soCategoryIds);
			}
			
			//delete data so_category
			List<CatalogDataEdit> delScDatas = catalogDataEditRepository.findByTypeAndCatalogId(TypeRestaurantDataEditEnum.DELETE_SO_CATEGORY.val, soId);
			if(delScDatas != null && !delScDatas.isEmpty()) {
				delScDatas.stream().forEach(item ->{
					List<String> codes = delScDatas.stream().map(i -> i.getValue()).collect(Collectors.toList());
					List<SoCategory> soCates = soCategoryRepository.findByRestaurantCodeAndOrderCateCode(codes,resCode);
					if(soCates != null && !soCates.isEmpty()) {
						soCates.stream().forEach(soCategory ->{
							String orderCategoryCode = soCategory.getOrderCategory().getCode();
							CoCategory coCategory = coCategoryRepository.findBySoCategoryAndRestaurantCode(soCategory, resCode);
							if(coCategory != null) {
								deleteCoCategory(coCategory);
								saveRestaurantDataEdit(resCode, TypeRestaurantDataEditEnum.DELETE_CO_CATEGORY.val, orderCategoryCode);
							}
							deleteSoCategory(soCategory,true); // delete soCategory if true
							saveRestaurantDataEdit(resCode, TypeRestaurantDataEditEnum.DELETE_SO_CATEGORY.val, orderCategoryCode);
						});
					}
				});
			}
		}
		
		
		//clone SoCategory
		if (soCategories != null && !soCategories.isEmpty()) {
			if(isOverride) {
				soCategories.stream().forEach(sc -> {
					String orderCategoryCode = sc.getOrderCategory().getCode();
					SoCategory soCategory = soCategoryRepository.findByOrderCategoryCodeAndResCode(orderCategoryCode, resCode);
					if(soCategory == null) {
						soCategory = new SoCategory();
					}
					
					soCategory.setAdultBufferTicket(sc.getAdultBufferTicket());
					soCategory.setKidBufferTicket(sc.getKidBufferTicket());
					soCategory.setOrderCategory(sc.getOrderCategory());
					soCategory.setOrderCategoryParentId(sc.getOrderCategoryParentId());
					soCategory.setRestaurantCode(resCode);
					soCategory.setType(sc.getType());
					soCategory.setSo(sc.getSo());
        			SoCategory clonedSoCategory = soCategoryRepository.save(soCategory);
        			
        			List<SoCategoryFoodGroup> soCategoryFoodGroups = sc.getSoCategoryFoodGroups();
        			List<SoCategoryFoodGroup> sCFoodGroups = new ArrayList<>();
        			List<SoCategoryFoodGroup> sCFoodGroupHasParents = new ArrayList<>();
        			if (soCategoryFoodGroups != null && !soCategoryFoodGroups.isEmpty()) {
        				soCategoryFoodGroups.stream().forEach(scfg ->{
        					if(scfg.getFoodGroup().getParent() != null) {
        						sCFoodGroupHasParents.add(scfg);
        					} else {
        						sCFoodGroups.add(scfg);
        					}
        				});
        				
        				if(sCFoodGroups != null && !sCFoodGroups.isEmpty()) {
        					cloneFoodGroups(sCFoodGroups, username, resCode, clonedSoCategory);
        				}
        				if(sCFoodGroupHasParents != null && !sCFoodGroupHasParents.isEmpty()) {
        					cloneFoodGroups(sCFoodGroupHasParents, username, resCode, clonedSoCategory);
        				}
        			}
	    		});
			} else {
				
				List<String> orderCodeDels = new ArrayList<>();
//				orderCodeDels.addAll(restaurantDataEditRepository.findValues(resCode, TypeRestaurantDataEditEnum.DELETE_SO_CATEGORY_OLD.val));
//				orderCodeDels.addAll(restaurantDataEditRepository.findValues(resCode, TypeRestaurantDataEditEnum.DELETE_SO_CATEGORY.val));
				orderCodeDels.addAll(restaurantDataEditRepository.findValues(resCode, TypeRestaurantDataEditEnum.DEL_SO_CATEGORY_OLD_RES.val));
				orderCodeDels.addAll(restaurantDataEditRepository.findValues(resCode, TypeRestaurantDataEditEnum.DELETE_SO_CATEGORY_RES.val));
				soCategories.stream().forEach(sc -> {
					String orderCategoryCode = sc.getOrderCategory().getCode();
					if(!orderCodeDels.contains(orderCategoryCode)) {
						SoCategory soCategory = soCategoryRepository.findByOrderCategoryCodeAndResCode(orderCategoryCode, resCode);
						//set type if type in soCategory change
	    				CoCategory coCategory = coCategoryRepository.findByorderCategoryCodeAndResCode(sc.getOrderCategory().getCode(),resCode);
						if(soCategory == null || soCategory.getSo() != null) {
							if(soCategory == null) {
								soCategory = new SoCategory();
							}
							soCategory.setAdultBufferTicket(sc.getAdultBufferTicket());
							soCategory.setKidBufferTicket(sc.getKidBufferTicket());
							soCategory.setOrderCategory(sc.getOrderCategory());
							soCategory.setOrderCategoryParentId(sc.getOrderCategoryParentId());
							soCategory.setRestaurantCode(resCode);
							soCategory.setType(sc.getType());
							soCategory.setSo(sc.getSo());
							if(coCategory != null) {
		        				coCategory.setType(sc.getType());
		        				CoCategory coCategoryNew = coCategoryRepository.save(coCategory);
		        				saveRestaurantDataEdit(resCode, TypeRestaurantDataEditEnum.CO_CATEGORY.val, coCategoryNew.getId().toString());
		        			}
						}
	        			SoCategory clonedSoCategory = soCategoryRepository.save(soCategory);
	        			restaurantDataEditRepository.deleteByValueAndRestaurantCodeAndType(orderCategoryCode, resCode, TypeRestaurantDataEditEnum.DELETE_SO_CATEGORY.val);
	        			restaurantDataEditRepository.deleteByValueAndRestaurantCodeAndType(orderCategoryCode, resCode, TypeRestaurantDataEditEnum.DELETE_CO_CATEGORY.val);
	        			saveRestaurantDataEdit(resCode, TypeRestaurantDataEditEnum.SO_CATEGORY.val, clonedSoCategory.getId().toString());
	            			
	        			List<SoCategoryFoodGroup> soCategoryFoodGroups = sc.getSoCategoryFoodGroups();
	        			List<SoCategoryFoodGroup> sCFoodGroups = new ArrayList<>();
	        			List<SoCategoryFoodGroup> sCFoodGroupHasParents = new ArrayList<>();
	        			
	        			List<SoCategoryFoodGroup> sCFoodGroupDels = new ArrayList<>();
	        			List<SoCategoryFoodGroup> sCFoodGroupdelHasParents = new ArrayList<>();
	        			
	        			List<String> foodGroupCodeDels = new ArrayList<>();
	        			
	        			
	        			if (soCategoryFoodGroups != null && !soCategoryFoodGroups.isEmpty()) {
	        				soCategoryFoodGroups.stream().forEach(scfg ->{
	        					if(scfg.getFoodGroup().getChanged() != null && scfg.getFoodGroup().getChanged().equals(StatusEnum.ACTIVE.status)){
	        						if(scfg.getFoodGroup().getParent() != null) {
		        						sCFoodGroupHasParents.add(scfg);
		        					} else {
		        						sCFoodGroups.add(scfg);
		        					}
	        					} else if(scfg.getFoodGroup().getChanged() != null && scfg.getFoodGroup().getChanged().equals(StatusEnum.DELETE.status)){
	        						if(scfg.getFoodGroup().getParent() != null) {
	        							sCFoodGroupdelHasParents.add(scfg);
		        					} else {
		        						sCFoodGroupDels.add(scfg);
		        					}
	        					}
	        				});
	        				
	        				// delete foodGroup
	        				if(sCFoodGroupdelHasParents != null && !sCFoodGroupdelHasParents.isEmpty()) {
	        					foodGroupCodeDels.addAll(deleteFoodGroup(sCFoodGroupdelHasParents, resCode, clonedSoCategory));
	        				}
	        				if(sCFoodGroupDels != null && !sCFoodGroupDels.isEmpty()) {
	        					foodGroupCodeDels.addAll(deleteFoodGroup(sCFoodGroupDels, resCode, clonedSoCategory));
	        				}
	        				
	        				// set CoFoodGroupDisplay
	        				if(coCategory != null && foodGroupCodeDels != null && !foodGroupCodeDels.isEmpty()){
	        					coFoodGroupDisplayRepository.deleteByCoCategoryAndFoodGroupCodeIn(coCategory, foodGroupCodeDels);
	        					saveRestaurantDataEdit(resCode, TypeRestaurantDataEditEnum.CO_CATEGORY.val, coCategory.getId().toString());
	        				}
	        				
	        				//clone foodGroup
	        				if(sCFoodGroups != null && !sCFoodGroups.isEmpty()) {
	        					cloneFoodGroups(sCFoodGroups, username, resCode, clonedSoCategory);
	        				}
	        				if(sCFoodGroupHasParents != null && !sCFoodGroupHasParents.isEmpty()) {
	        					cloneFoodGroups(sCFoodGroupHasParents, username, resCode, clonedSoCategory);
	        				}
	        			}
					}
	    		});
			}
    	}
	}
	
	// delete foodGroup
	private List<String> deleteFoodGroup(List<SoCategoryFoodGroup> soCategoryFoodGroups,Integer resCode,SoCategory soCategory){
		List<String> foodGroupCodeDels = new ArrayList<>();
		List<String> foodGroupCodeChanged = new ArrayList<>();
		foodGroupCodeChanged.addAll((foodGroupRepository.findFCodeByResCodeAndScIdAndChanged(resCode, soCategory.getId(),StatusEnum.ACTIVE.status)));
		foodGroupCodeChanged.addAll((foodGroupRepository.findFCodeByResCodeAndScIdAndChanged(resCode, soCategory.getId(),StatusEnum.DELETE.status)));
		soCategoryFoodGroups.stream().forEach(scfg ->{
			FoodGroup foodGroup = scfg.getFoodGroup();
			String foodGroupCode = foodGroup.getCode();
			if(!foodGroupCodeChanged.contains(foodGroupCode)) {
				FoodGroup delFoodGroup = foodGroupRepository.findByCodeAndRestaurantCode(foodGroupCode, resCode);
				if(delFoodGroup != null) {
					foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(delFoodGroup, resCode);
					soCategoryFoodGroupRepository.deleteByFoodGroupAndSoCategoryAndRestaurantCode(delFoodGroup, soCategory, resCode);
					delAttachment(delFoodGroup.getId(), ModuleTypeEnum.FOOD_GROUP.val);
					foodGroupRepository.delete(delFoodGroup);
					/*delFoodGroup.setChanged(StatusEnum.DELETE.status);
					foodGroupRepository.save(delFoodGroup);*/
					foodGroupCodeDels.add(delFoodGroup.getCode());
				} 
			}
		});
		
		return foodGroupCodeDels;
	}
	
	//clone attachment
	private void saveAttachment(Long currentModuleId, Long newModuleId, String moduleType) {
		List<Attachment> attachments = attachmentRepository.findByModuleIdAndModuleType(currentModuleId, moduleType);
		if(attachments != null && !attachments.isEmpty()) {
			attachments.stream().forEach(item ->{
				Attachment attachment = new Attachment();
				attachment.setModuleId(newModuleId);
				attachment.setModuleType(moduleType);
				attachment.setFunctionType(item.getFunctionType());
				attachment.setName(item.getName());
				attachment.setUrl(item.getUrl());
				attachment.setAbsolutePath(item.getAbsolutePath());
				attachment.setFileName(item.getFileName());
				attachment.setFileType(item.getFileType());
				attachment.setVersion(item.getVersion());
				attachmentRepository.save(attachment);
			});
		}
	}
	
	//clone FoodGroup
	private void cloneFoodGroups(List<SoCategoryFoodGroup> soCategoryFoodGroups,String username,Integer resCode,SoCategory soCategory) {
		log.debug("Entering 'cloneFoodGroup(List<SoCategoryFoodGroup> soCategoryFoodGroups,String username,Integer resCode,SoCategory soCategory)' method...");
		List<String> foodGroupCodeDels = foodGroupRepository.findFCodeByResCodeAndScIdAndChanged(resCode, soCategory.getId(),StatusEnum.DELETE.status);
		List<Long> delFoodGroupItemIds = new ArrayList<>();
		List<Long> delSoCateFoodGroupIds = new ArrayList<>();
		soCategoryFoodGroups.stream().forEach(scfg ->{
			FoodGroup foodGroup = scfg.getFoodGroup();
			String foodGroupCode = foodGroup.getCode();
			if(!foodGroupCodeDels.contains(foodGroupCode)) {
				FoodGroup newFoodGroup = foodGroupRepository.findByCodeAndRestaurantCode(foodGroupCode, resCode);
				if(newFoodGroup == null || newFoodGroup.getChanged().equals(StatusEnum.INACTIVE.status)) {
					if(newFoodGroup == null) {
						newFoodGroup = new FoodGroup();
					} else {
						delFoodGroupItemIds.addAll(foodGroupItemRepository.findByFoodGroupAndRestaurantCode(newFoodGroup, resCode).stream().map(item -> item.getId()).collect(Collectors.toList()));
						delSoCateFoodGroupIds.addAll(soCategoryFoodGroupRepository.findFoodGroupAndSoCategoryAndRestaurantCode(foodGroupCode, soCategory.getId(), resCode).stream().map(item -> item.getId()).collect(Collectors.toList()));
						delAttachment(newFoodGroup.getId(), ModuleTypeEnum.FOOD_GROUP.val);
					}
					
					newFoodGroup.setCode(foodGroup.getCode());
					newFoodGroup.setCreatedBy(username);
					newFoodGroup.setMenuType(foodGroup.getMenuType());
					newFoodGroup.setModifiedBy(username);
					newFoodGroup.setNameEn(foodGroup.getNameEn());
					if(foodGroup.getNameVn() != null && !foodGroup.getNameVn().isEmpty()) {
						newFoodGroup.setNameVn(foodGroup.getNameVn());
						newFoodGroup.setUnsignedName(org.apache.commons.lang3.StringUtils.stripAccents(foodGroup.getNameVn()).toLowerCase());
					}
					if(foodGroup.getParent() != null) {
						FoodGroup foodGroupParent = foodGroupRepository.findById(foodGroup.getParent().getId()).get();
						FoodGroup foodGroupParentNew = foodGroupRepository.findByCodeAndRestaurantCode(foodGroupParent.getCode(), resCode);
						newFoodGroup.setParent(foodGroupParentNew);
					}
					newFoodGroup.setLevel(foodGroup.getLevel());
					newFoodGroup.setSrcImage(foodGroup.getSrcImage());
					newFoodGroup.setRestaurantCode(resCode);
					newFoodGroup.setChanged(StatusEnum.INACTIVE.status);
					FoodGroup fg = foodGroupRepository.save(newFoodGroup);
					//clone attachment
					saveAttachment(foodGroup.getId(), fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
					//clone SoCategory
					SoCategoryFoodGroup newSoCategoryFoodGroup = new SoCategoryFoodGroup();
					newSoCategoryFoodGroup.setFoodGroup(fg);
					if(fg.getParent() != null) {
						newSoCategoryFoodGroup.setFoodGroupParentId(fg.getParent().getId());
					}
					newSoCategoryFoodGroup.setGroupOrder(scfg.getGroupOrder());
					newSoCategoryFoodGroup.setRestaurantCode(resCode);
					newSoCategoryFoodGroup.setSoCategory(soCategory);
					soCategoryFoodGroupRepository.save(newSoCategoryFoodGroup);
					//clone FoodGroupItem
					List<FoodGroupItem> foodGroupItems = foodGroupItemRepository.findByFoodGroupAndRestaurantCodeIsNull(foodGroup);
					foodGroupItems.stream().forEach(fgi -> {
						FoodGroupItem newFoodGroupItem = new FoodGroupItem();
						newFoodGroupItem.setFoodGroup(fg);
						newFoodGroupItem.setFoodItem(fgi.getFoodItem());
						newFoodGroupItem.setItemOrder(fgi.getItemOrder());
						newFoodGroupItem.setChanged(StatusEnum.ACTIVE.status);
						newFoodGroupItem.setRestaurantCode(resCode);
						foodGroupItemRepository.save(newFoodGroupItem);
					});
				} else {
					//clone FoodGroupItem
					List<FoodGroupItem> foodGroupItemInCatalogs = foodGroupItemRepository.findByFoodGroupAndRestaurantCodeIsNull(foodGroup);
					FoodGroup fGroup = newFoodGroup;
					List<FoodGroupItem> foodGroupItemInRes = foodGroupItemRepository.findByFoodGroupAndChangedAndRestaurantCode(newFoodGroup, StatusEnum.ACTIVE.status, resCode);
					if(foodGroupItemInCatalogs != null && !foodGroupItemInCatalogs.isEmpty()) {
						if(foodGroupItemInRes != null && !foodGroupItemInRes.isEmpty()) {
							
							List<Long> foodGroupItemIdInCatalogs = foodGroupItemInCatalogs.stream().map(fgi ->fgi.getFoodItem().getId()).collect(Collectors.toList());
							List<Long> foodGroupItemIdInRes = foodGroupItemInRes.stream().map(fgi ->fgi.getFoodItem().getId()).collect(Collectors.toList());
							
							List<Long> fGIIdDeleteInRes = foodGroupItemRepository.findByFoodGroupAndChangedAndRestaurantCode(newFoodGroup, StatusEnum.DELETE.status, resCode).stream().map(fgi ->fgi.getFoodItem().getId()).collect(Collectors.toList());
							List<Long> fGIIdInResAddeds = foodGroupItemRepository.findByFoodGroupAndChangedAndRestaurantCode(newFoodGroup, null, resCode).stream().map(fgi ->fgi.getFoodItem().getId()).collect(Collectors.toList());
							
							List<Long> newFoodItemIds = new ArrayList<>();
							List<Long> deletedFoodItemIds = new ArrayList<>();
							foodGroupItemIdInRes.stream().forEach(fiId -> {
								if (!foodGroupItemIdInCatalogs.contains(fiId)) {
									deletedFoodItemIds.add(fiId);
								}
							});
							foodGroupItemIdInCatalogs.stream().forEach(fiId -> {
								if (!foodGroupItemIdInRes.contains(fiId)) {
									newFoodItemIds.add(fiId);
								}
							});
							
							if (!deletedFoodItemIds.isEmpty()) {
								deletedFoodItemIds.stream().forEach(fiId -> {
									FoodItem foodItem = new FoodItem();
									foodItem.setId(fiId);
									foodGroupItemRepository.deleteByFoodGroupAndChangedAndRestaurantCode(fGroup, StatusEnum.ACTIVE.status,resCode);
								});
							}
							if (!newFoodItemIds.isEmpty()) {
								Integer size = foodGroupItemIdInRes.size() + fGIIdInResAddeds.size();
								for ( int i = 0; i < newFoodItemIds.size(); i++) {
									Long fiId = newFoodItemIds.get(i);
									FoodItem foodItem = new FoodItem();
									foodItem.setId(fiId);
									if(!fGIIdDeleteInRes.contains(fiId) && !fGIIdInResAddeds.contains(fiId)) {
										FoodGroupItem fGroupItem = new FoodGroupItem();
										fGroupItem.setItemOrder(size + i + 1);
										fGroupItem.setFoodGroup(fGroup);
										fGroupItem.setFoodItem(foodItem);
										fGroupItem.setRestaurantCode(resCode);	
										fGroupItem.setChanged(StatusEnum.ACTIVE.status);
										foodGroupItemRepository.save(fGroupItem);
									}
								}
							}
							
						} else {
							foodGroupItemInCatalogs.stream().forEach(fgi -> {
								FoodGroupItem newFoodGroupItem = new FoodGroupItem();
								newFoodGroupItem.setFoodGroup(fGroup);
								newFoodGroupItem.setFoodItem(fgi.getFoodItem());
								newFoodGroupItem.setItemOrder(fgi.getItemOrder());
								newFoodGroupItem.setChanged(StatusEnum.ACTIVE.status);
								newFoodGroupItem.setRestaurantCode(resCode);
								foodGroupItemRepository.save(newFoodGroupItem);
							});
						}
					} else {
						foodGroupItemRepository.deleteByFoodGroupAndChangedAndRestaurantCode(newFoodGroup, StatusEnum.ACTIVE.status, resCode);
					}
				}
			}
		});
		if(!delFoodGroupItemIds.isEmpty()) {
			foodGroupItemRepository.deleteByIdIn(delFoodGroupItemIds);
		}
		if(!delSoCateFoodGroupIds.isEmpty()) {
			soCategoryFoodGroupRepository.deleteByIdIn(delSoCateFoodGroupIds);
		}
	}

	// copy SoCategory
	private void copySoCategory(List<SoCategory> soCategories,Integer resCode, boolean isOverride,String username) {
		log.debug("Entering 'copySoCategory(List<SoCategory> soCategories,Integer resCode, boolean isOverride,String username)' method...");
		// delete data before update
		delRestaurantSoData(resCode, isOverride); 
		restaurantDataEditRepository.deleteByRestaurantCode(resCode);
		
		if (soCategories != null && !soCategories.isEmpty()) {
			soCategories.stream().forEach(sc -> {
				String orderCategoryCode = sc.getOrderCategory().getCode();
				SoCategory soCategory = soCategoryRepository.findByOrderCategoryCodeAndResCode(orderCategoryCode, resCode);
				if(soCategory == null) {
					soCategory = new SoCategory();
				}
				
				soCategory.setAdultBufferTicket(sc.getAdultBufferTicket());
				soCategory.setKidBufferTicket(sc.getKidBufferTicket());
				soCategory.setOrderCategory(sc.getOrderCategory());
				soCategory.setOrderCategoryParentId(sc.getOrderCategoryParentId());
				soCategory.setRestaurantCode(resCode);
				soCategory.setType(sc.getType());
				soCategory.setSo(sc.getSo());
    			SoCategory clonedSoCategory = soCategoryRepository.save(soCategory);
    			
    			List<SoCategoryFoodGroup> soCategoryFoodGroups = sc.getSoCategoryFoodGroups();
    			List<SoCategoryFoodGroup> sCFoodGroups = new ArrayList<>();
    			List<SoCategoryFoodGroup> sCFoodGroupHasParents = new ArrayList<>();
    			if (soCategoryFoodGroups != null && !soCategoryFoodGroups.isEmpty()) {
    				soCategoryFoodGroups.stream().forEach(scfg ->{
    					if(scfg.getFoodGroup().getParent() != null) {
    						sCFoodGroupHasParents.add(scfg);
    					} else {
    						sCFoodGroups.add(scfg);
    					}
    				});
    				
    				if(sCFoodGroups != null && !sCFoodGroups.isEmpty()) {
    					cloneFoodGroups(sCFoodGroups, username, resCode, clonedSoCategory);
    				}
    				if(sCFoodGroupHasParents != null && !sCFoodGroupHasParents.isEmpty()) {
    					cloneFoodGroups(sCFoodGroupHasParents, username, resCode, clonedSoCategory);
    				}
    			}
    		});
		}
	}
	
	private void saveRestaurantDataEdit(Integer resCode, String type, String value) {
		log.info("Entering 'saveRestaurantDataEdit(Integer resCode, String type, Long itemId)' method...");
		log.debug("Params: resCode: " + resCode + ", type: " + type + ", value: " + value);
		restaurantDataEditRepository.deleteByValueAndRestaurantCodeAndType(value, resCode, type);
		RestaurantDataEdit restaurantDataEdit = restaurantDataEditRepository.findByValueAndRestaurantCodeAndType(value, resCode, type);
		if(restaurantDataEdit == null) {
			restaurantDataEdit = new RestaurantDataEdit();
		}
		restaurantDataEdit.setValue(value);
		restaurantDataEdit.setRestaurantCode(resCode);
		restaurantDataEdit.setType(type);
		restaurantDataEditRepository.save(restaurantDataEdit);
	}
	
	// copy data from restaurant to restaurant same brand
	public void copyToOthers(final String username, final SoCategoryDto criteria) {
		log.info("Entering 'copyToOthers(username, criteria)' method...");
		log.debug("Params: username: "+username+", fromResCode: "+criteria.getRestaurantCode()+", toResCodes: "+criteria.getResCodes()+", isOverride: "+criteria.isOverride());
		
		Integer fromResCode = criteria.getRestaurantCode();
		List<Integer> toResCodes = criteria.getResCodes();
		boolean isOverride = criteria.isOverride();
    		
		CatalogApplyToRestaurant applyToRestaurant = catalogApplyToRestaurantRepository.findByRestaurantCode(fromResCode);
		Long soId = applyToRestaurant.getSoId();
		
		List<SoCategory> soCategories = soCategoryRepository.findByRestaurantCode(fromResCode);
		
		
		if (fromResCode != null && toResCodes != null && !toResCodes.isEmpty()) {
			if(isOverride) {
				toResCodes.stream().forEach(toResCode ->{
					copySoCategory(soCategories, toResCode, true,username);
					saveCatalogApply(toResCode,soId,true);
				});
			} else {
				List<CatalogApplyToRestaurant> applyToRestaurants = catalogApplyToRestaurantRepository.findBySoId(soId);
				if(applyToRestaurants != null && !applyToRestaurants.isEmpty()) {
					List<Integer> resCodes = applyToRestaurants.stream().map(r -> r.getRestaurantCode()).collect(Collectors.toList());
					toResCodes.stream().forEach(toResCode ->{
						if(resCodes.contains(toResCode)) {
							//saveSoCategory(So so,Integer resCode, boolean isOverride,boolean isCopyToRes,String username)
							saveSoCategory(null, toResCode, false, false, username);
						} else {
							copySoCategory(soCategories, toResCode, true,username);
						}
						saveCatalogApply(toResCode,soId,false);
					});
				} else {
					toResCodes.stream().forEach(toResCode ->{
						copySoCategory(soCategories, toResCode, true,username);
						saveCatalogApply(toResCode,soId,false);
					});
				}
			}
			
		}
	}
	
	public SoDto getByRestaurantCode(Integer restaurantCode) {
		List<SoCategory> soCategories = soCategoryRepository.findByRestaurantCodeAndSoIsNotNull(restaurantCode);
		if(soCategories != null && !soCategories.isEmpty()) {
			SoCategory soCategory = soCategories.get(0);
			return Optional.ofNullable(soCategory.getSo()).map(soMapper::entityToDto).orElse(null);
		}
		return null;
	}

	// getTree catalog
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public FancyTree getTree(FancyTree comNode) {
		log.debug("entering 'getTree' method...");
		// set node so
		List<So> soLst = soRepository.findByStatusIsTrue();
    	if (!soLst.isEmpty()) {
    		List soNodes = new ArrayList();
    		soLst.stream().forEach(so -> {
    			FancyTree soNode = new FancyTree();
    			soNode.setTitle(so.getName());
    			List<SoCategory> soCategories = soCategoryRepository.findBySoAndRestaurantCodeIsNull(so);
    			if (soCategories != null && !soCategories.isEmpty()) {
    				List soCategoryNodes = new ArrayList();
    				soCategories.stream().forEach(soCategory -> {
    					FancyTree soCategoryNode = new FancyTree();
    					StringBuilder title = new StringBuilder();
						title.append(soCategory.getOrderCategory().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(soCategory.getOrderCategory().getName());
    					soCategoryNode.setTitle(title.toString());
							List<FoodGroup> foodGroups = foodGroupRepository.findByRCodeIsNullAndScIdAndChanged(soCategory.getId(),StatusEnum.DELETE.status);
							if (foodGroups != null && !foodGroups.isEmpty()) {
								List foodGroupNodes = new ArrayList();
								foodGroups.stream().forEach(fg -> {
									FancyTree foodGroupNode = new FancyTree();
									StringBuilder titleFg = new StringBuilder();
									titleFg.append(fg.getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fg.getNameVn());
									StringBuilder keyFg = new StringBuilder();
									// foodGroupCode - soCategoryId - SoId
									keyFg.append(fg.getCode()).append(SymbolEnum.HYPHEN.val).append(soCategory.getId()).append(SymbolEnum.HYPHEN.val).append(so.getId());
									foodGroupNode.setTitle(titleFg.toString());
									foodGroupNode.setKey(keyFg.toString());
									foodGroupNodes.add(foodGroupNode);
								});
								soCategoryNode.setChildren(foodGroupNodes);
							}
						soCategoryNodes.add(soCategoryNode);
    				});
    				soNode.setChildren(soCategoryNodes);
    			}
    			soNodes.add(soNode);
    		});
    		comNode.setChildren(soNodes);
    	}
    	return comNode;
	}
	
	// find by keyword FoodItem
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public FancyTree getTree(String keywordFoodGroup,String keywordFoodItem, FancyTree comNode,List<String> fICodeSelected,List<String> fGCodeSelected) {
		log.debug("entering 'getTree' method...");
		// set node so
		if(keywordFoodItem != null && !keywordFoodItem.isEmpty()) {
			List<FoodGroup> fGroups = new ArrayList<>();
			List<FoodGroupItem> fGItems = new ArrayList<>();

			if(keywordFoodItem != null && !keywordFoodItem.isEmpty() && keywordFoodGroup != null && !keywordFoodGroup.isEmpty()) {
				fGItems = foodGroupItemRepository.findByFiCodeorNameAndFgCodeorNameAndChanged(org.apache.commons.lang3.StringUtils.stripAccents(keywordFoodItem).toLowerCase(),StatusEnum.DELETE.status,org.apache.commons.lang3.StringUtils.stripAccents(keywordFoodGroup).toLowerCase());
//					fGroups = foodGroupRepository.findByCodeOrNameVn(org.apache.commons.lang3.StringUtils.stripAccents(keywordFoodGroup).toLowerCase(),StatusEnum.DELETE.status);
			}else if(keywordFoodItem != null && !keywordFoodItem.isEmpty() && (keywordFoodGroup == null || keywordFoodGroup.isEmpty())) {
				fGItems = foodGroupItemRepository.findByFiCodeorNameAndChanged(org.apache.commons.lang3.StringUtils.stripAccents(keywordFoodItem).toLowerCase(),StatusEnum.DELETE.status);
				System.out.println("fGroups :" + fGroups);
			}
			
//				if(fGCodeSelected != null && !fGCodeSelected.isEmpty()) {
//					fGroups.addAll(foodGroupRepository.findByFGCodeIn(fGCodeSelected, StatusEnum.DELETE.status));
//				}
			
//				if(fICodeSelected != null && !fICodeSelected.isEmpty()) {
//					fItems.addAll(foodItemRepository.findByCodeIn(fICodeSelected, StatusEnum.DELETE.status,fGCodeSelected));
//				}
			fGroups.addAll(fGItems.stream().map(item -> item.getFoodGroup()).collect(Collectors.toList()));
			List<String> fgCodes = fGroups.stream().map(item -> item.getCode()).collect(Collectors.toList());
			List<String> fiCodes = fGItems.stream().map(item -> item.getFoodItem().getCode()).collect(Collectors.toList());
			System.out.println("fgCodes :" + fgCodes);
			List<SoCategory> categories = fGroups.stream().map(item -> item.getSoCategoryFoodGroups().get(0).getSoCategory()).collect(Collectors.toList());
			System.out.println("categories :" + categories);
			if(categories != null && !categories.isEmpty()) {
				List<Long> soCategoryIds = categories.stream().map(item -> item.getId()).collect(Collectors.toList());
				System.out.println("soCategoryIds :" + soCategoryIds);
				List<Long> soIds = categories.stream().map(item -> item.getSo().getId()).collect(Collectors.toList());
				List<So> soLst = soRepository.findByStatusIsTrue();
		    	if (!soLst.isEmpty()) {
		    		List soNodes = new ArrayList();
		    		soLst.stream().forEach(so -> {
		    			if(soIds.contains(so.getId())) {
		    				FancyTree soNode = new FancyTree();
			    			soNode.setTitle(so.getName());
			    			List<SoCategory> soCategories = soCategoryRepository.findBySoAndRestaurantCodeIsNull(so);
			    			if (soCategories != null && !soCategories.isEmpty()) {
			    				List soCategoryNodes = new ArrayList();
			    				soCategories.stream().forEach(soCategory -> {
			    					if(soCategoryIds.contains(soCategory.getId())) {
			    						FancyTree soCategoryNode = new FancyTree();
				    					StringBuilder title = new StringBuilder();
										title.append(soCategory.getOrderCategory().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(soCategory.getOrderCategory().getName());
				    					soCategoryNode.setTitle(title.toString());
											List<FoodGroup> foodGroups = foodGroupRepository.findByRCodeIsNullAndScIdAndChanged(soCategory.getId(),StatusEnum.DELETE.status);
											if (foodGroups != null && !foodGroups.isEmpty()) {
												List foodGroupNodes = new ArrayList();
												foodGroups.stream().forEach(fg -> {
													if(fgCodes.contains(fg.getCode())) {
														FancyTree foodGroupNode = new FancyTree();
														StringBuilder titleFg = new StringBuilder();
														titleFg.append(fg.getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fg.getNameVn());
														foodGroupNode.setTitle(titleFg.toString());
															List<FoodGroupItem> foodGroupItems = fg.getFoodGroupItems();
															if(foodGroupItems != null && !foodGroupItems.isEmpty()) {
																List foodGroupItemNodes = new ArrayList();
																foodGroupItems.stream().forEach(fgi ->{
																	if(fiCodes.contains(fgi.getFoodItem().getCode())) {
																		FancyTree foodGroupItemNode = new FancyTree();
																		StringBuilder titleFgi = new StringBuilder();
																		String sapCode = "";
																		if(fgi.getFoodItem().getSapCode() != null && !fgi.getFoodItem().getSapCode().isEmpty()) {
																			sapCode = fgi.getFoodItem().getSapCode();
																		}
																		titleFgi.append(sapCode).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fgi.getFoodItem().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fgi.getFoodItem().getName());
																		foodGroupItemNode.setTitle(titleFgi.toString());
																		StringBuilder keyFg = new StringBuilder();
																		// foodGroupCode - soCategoryId - SoId - foodItemCode
																		keyFg.append(fg.getCode()).append(SymbolEnum.HYPHEN.val).append(soCategory.getId()).append(SymbolEnum.HYPHEN.val).append(so.getId()).append(SymbolEnum.HYPHEN.val).append(fgi.getFoodItem().getCode());
																		foodGroupItemNode.setKey(keyFg.toString());
																		if (fICodeSelected != null && !fICodeSelected.isEmpty() && fICodeSelected.contains(fgi.getFoodItem().getCode())) {
																			foodGroupItemNode.setSelected(true);
																		}
																		foodGroupItemNodes.add(foodGroupItemNode);
																	}
																});
																foodGroupNode.setChildren(foodGroupItemNodes);
															}
														foodGroupNodes.add(foodGroupNode);
													}
												});
												soCategoryNode.setChildren(foodGroupNodes);
											}
										soCategoryNodes.add(soCategoryNode);
			    					}
			    				});
			    				soNode.setChildren(soCategoryNodes);
			    			}
			    			soNodes.add(soNode);
		    			}
		    		});
		    		comNode.setChildren(soNodes);
		    	}
			}
		} else {
			List<So> soLst = soRepository.findByStatusIsTrue();
	    	if (!soLst.isEmpty()) {
	    		List soNodes = new ArrayList();
	    		soLst.stream().forEach(so -> {
	    			FancyTree soNode = new FancyTree();
	    			soNode.setTitle(so.getName());
	    			List<SoCategory> soCategories = soCategoryRepository.findBySoAndRestaurantCodeIsNull(so);
	    			if (soCategories != null && !soCategories.isEmpty()) {
	    				List soCategoryNodes = new ArrayList();
	    				soCategories.stream().forEach(soCategory -> {
	    					FancyTree soCategoryNode = new FancyTree();
	    					StringBuilder title = new StringBuilder();
							title.append(soCategory.getOrderCategory().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(soCategory.getOrderCategory().getName());
	    					soCategoryNode.setTitle(title.toString());
								List<FoodGroup> foodGroups = foodGroupRepository.findByRCodeIsNullAndScIdAndChanged(soCategory.getId(),StatusEnum.DELETE.status);
								if (foodGroups != null && !foodGroups.isEmpty()) {
									List foodGroupNodes = new ArrayList();
									foodGroups.stream().forEach(fg -> {
										FancyTree foodGroupNode = new FancyTree();
										StringBuilder titleFg = new StringBuilder();
										titleFg.append(fg.getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fg.getNameVn());
										foodGroupNode.setTitle(titleFg.toString());
											List<FoodGroupItem> foodGroupItems = fg.getFoodGroupItems();
												if(foodGroupItems != null && !foodGroupItems.isEmpty()) {
													List foodGroupItemNodes = new ArrayList();
													foodGroupItems.stream().forEach(fgi ->{
														FancyTree foodGroupItemNode = new FancyTree();
														StringBuilder titleFgi = new StringBuilder();
														String sapCode = "";
														if(fgi.getFoodItem().getSapCode() != null && !fgi.getFoodItem().getSapCode().isEmpty()) {
															sapCode = fgi.getFoodItem().getSapCode();
														}
														titleFgi.append(sapCode).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fgi.getFoodItem().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fgi.getFoodItem().getName());
														foodGroupItemNode.setTitle(titleFgi.toString());
														StringBuilder keyFg = new StringBuilder();
														// foodGroupCode - soCategoryId - SoId - foodItemCode
														keyFg.append(fg.getCode()).append(SymbolEnum.HYPHEN.val).append(soCategory.getId()).append(SymbolEnum.HYPHEN.val).append(so.getId()).append(SymbolEnum.HYPHEN.val).append(fgi.getFoodItem().getCode());
														foodGroupItemNode.setKey(keyFg.toString());
														if (fICodeSelected != null && !fICodeSelected.isEmpty() && fICodeSelected.contains(fgi.getFoodItem().getCode())) {
															foodGroupItemNode.setSelected(true);
														}
														foodGroupItemNodes.add(foodGroupItemNode);
													});
													foodGroupNode.setChildren(foodGroupItemNodes);
												}
										foodGroupNodes.add(foodGroupNode);
									});
									soCategoryNode.setChildren(foodGroupNodes);
								}
							soCategoryNodes.add(soCategoryNode);
	    				});
	    				soNode.setChildren(soCategoryNodes);
	    			}
	    			soNodes.add(soNode);
	    		});
	    		comNode.setChildren(soNodes);
	    	}
		}
		
    	return comNode;
	}
	
	
	// find by keyword - foodGroup
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public FancyTree getTree(String keyword, FancyTree comNode,List<String> fGCodeSelected) {
		log.debug("entering 'getTree' method...");
		// set node so
		if(keyword != null && !keyword.isEmpty()) {
			List<FoodGroup> fGroups = new ArrayList<>();
			if(keyword != null && !keyword.isEmpty()) {
				System.out.println("org.apache.commons.lang3.StringUtils.stripAccents(keyword) :"+ org.apache.commons.lang3.StringUtils.stripAccents(keyword));
				fGroups = foodGroupRepository.findByCodeOrNameVn(org.apache.commons.lang3.StringUtils.stripAccents(keyword).toLowerCase(),StatusEnum.DELETE.status);
				System.out.println("fGroups :" + fGroups);
			}
			if(fGCodeSelected != null && !fGCodeSelected.isEmpty()) {
				fGroups.addAll(foodGroupRepository.findByFGCodeIn(fGCodeSelected, StatusEnum.DELETE.status));
			}
			
			List<String> fgCodes = fGroups.stream().map(item -> item.getCode()).collect(Collectors.toList());
			System.out.println("fgCodes :" + fgCodes);
			List<SoCategory> categories = fGroups.stream().map(item -> item.getSoCategoryFoodGroups().get(0).getSoCategory()).collect(Collectors.toList());
			System.out.println("categories :" + categories);
			if(categories != null && !categories.isEmpty()) {
				List<Long> soCategoryIds = categories.stream().map(item -> item.getId()).collect(Collectors.toList());
				System.out.println("soCategoryIds :" + soCategoryIds);
				List<Long> soIds = categories.stream().map(item -> item.getSo().getId()).collect(Collectors.toList());
				List<So> soLst = soRepository.findByStatusIsTrue();
		    	if (!soLst.isEmpty()) {
		    		List soNodes = new ArrayList();
		    		soLst.stream().forEach(so -> {
		    			if(soIds.contains(so.getId())) {
		    				FancyTree soNode = new FancyTree();
			    			soNode.setTitle(so.getName());
			    			List<SoCategory> soCategories = soCategoryRepository.findBySoAndRestaurantCodeIsNull(so);
			    			if (soCategories != null && !soCategories.isEmpty()) {
			    				List soCategoryNodes = new ArrayList();
			    				soCategories.stream().forEach(soCategory -> {
			    					if(soCategoryIds.contains(soCategory.getId())) {
			    						FancyTree soCategoryNode = new FancyTree();
				    					StringBuilder title = new StringBuilder();
										title.append(soCategory.getOrderCategory().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(soCategory.getOrderCategory().getName());
				    					soCategoryNode.setTitle(title.toString());
											List<FoodGroup> foodGroups = foodGroupRepository.findByRCodeIsNullAndScIdAndChanged(soCategory.getId(),StatusEnum.DELETE.status);
											if (foodGroups != null && !foodGroups.isEmpty()) {
												List foodGroupNodes = new ArrayList();
												foodGroups.stream().forEach(fg -> {
													if(fgCodes.contains(fg.getCode())) {
														FancyTree foodGroupNode = new FancyTree();
														StringBuilder titleFg = new StringBuilder();
														titleFg.append(fg.getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fg.getNameVn());
														StringBuilder keyFg = new StringBuilder();
														// foodGroupCode - soCategoryId - SoId
														keyFg.append(fg.getCode()).append(SymbolEnum.HYPHEN.val).append(soCategory.getId()).append(SymbolEnum.HYPHEN.val).append(so.getId());
														foodGroupNode.setTitle(titleFg.toString());
														foodGroupNode.setKey(keyFg.toString());
														if (fGCodeSelected != null && !fGCodeSelected.isEmpty() && fGCodeSelected.contains(fg.getCode())) {
															foodGroupNode.setSelected(true);
														}
														foodGroupNodes.add(foodGroupNode);
													}
												});
												soCategoryNode.setChildren(foodGroupNodes);
											}
										soCategoryNodes.add(soCategoryNode);
			    					}
			    				});
			    				soNode.setChildren(soCategoryNodes);
			    			}
			    			soNodes.add(soNode);
		    			}
		    		});
		    		comNode.setChildren(soNodes);
		    	}
			}
		} else {
			List<So> soLst = soRepository.findByStatusIsTrue();
	    	if (!soLst.isEmpty()) {
	    		List soNodes = new ArrayList();
	    		soLst.stream().forEach(so -> {
	    			FancyTree soNode = new FancyTree();
	    			soNode.setTitle(so.getName());
	    			List<SoCategory> soCategories = soCategoryRepository.findBySoAndRestaurantCodeIsNull(so);
	    			if (soCategories != null && !soCategories.isEmpty()) {
	    				List soCategoryNodes = new ArrayList();
	    				soCategories.stream().forEach(soCategory -> {
	    					FancyTree soCategoryNode = new FancyTree();
	    					StringBuilder title = new StringBuilder();
							title.append(soCategory.getOrderCategory().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(soCategory.getOrderCategory().getName());
	    					soCategoryNode.setTitle(title.toString());
								List<FoodGroup> foodGroups = foodGroupRepository.findByRCodeIsNullAndScIdAndChanged(soCategory.getId(),StatusEnum.DELETE.status);
								if (foodGroups != null && !foodGroups.isEmpty()) {
									List foodGroupNodes = new ArrayList();
									foodGroups.stream().forEach(fg -> {
										FancyTree foodGroupNode = new FancyTree();
										StringBuilder titleFg = new StringBuilder();
										titleFg.append(fg.getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fg.getNameVn());
										StringBuilder keyFg = new StringBuilder();
										// foodGroupCode - soCategoryId - SoId
										keyFg.append(fg.getCode()).append(SymbolEnum.HYPHEN.val).append(soCategory.getId()).append(SymbolEnum.HYPHEN.val).append(so.getId());
										foodGroupNode.setTitle(titleFg.toString());
										foodGroupNode.setKey(keyFg.toString());
										if (fGCodeSelected != null && !fGCodeSelected.isEmpty() && fGCodeSelected.contains(fg.getCode())) {
											foodGroupNode.setSelected(true);
										}
										foodGroupNodes.add(foodGroupNode);
									});
									soCategoryNode.setChildren(foodGroupNodes);
								}
							soCategoryNodes.add(soCategoryNode);
	    				});
	    				soNode.setChildren(soCategoryNodes);
	    			}
	    			soNodes.add(soNode);
	    		});
	    		comNode.setChildren(soNodes);
	    	}
		}
		
    	return comNode;
	}

	
	//reset SoCategory
	public void resetSoCategory(Integer resCode,String username) {
		log.debug("Entering 'resetSoCategory(Integer resCode,String username)' method...");
		CatalogApplyToRestaurant applyToRestaurant = catalogApplyToRestaurantRepository.findByRestaurantCode(resCode);
		List<SoCategory> soCateInRes = soCategoryRepository.findByRestaurantCodeAndSoIsNull(resCode);
		if(soCateInRes != null && !soCateInRes.isEmpty() && applyToRestaurant != null && applyToRestaurant.getSoId() != null) {
			soCateInRes.stream().forEach(item ->{
				String orderCategoryCode = item.getOrderCategory().getCode();
				SoCategory soCategory = soCategoryRepository.findByOrderCategoryCodeAndSoIdAndResCodeIsNull(orderCategoryCode, applyToRestaurant.getSoId());
				CoCategory coCategory = coCategoryRepository.findBySoCategoryAndRestaurantCode(item, resCode);
				if(soCategory != null) {
					// delete SoCategory
					deleteSoCategory(item);
					
					SoCategory newSoCate = new SoCategory();
					newSoCate.setAdultBufferTicket(soCategory.getAdultBufferTicket());
					newSoCate.setKidBufferTicket(soCategory.getKidBufferTicket());
					newSoCate.setOrderCategory(soCategory.getOrderCategory());
					newSoCate.setOrderCategoryParentId(soCategory.getOrderCategoryParentId());
					newSoCate.setRestaurantCode(resCode);
					newSoCate.setType(soCategory.getType());
					newSoCate.setSo(soCategory.getSo());
        			SoCategory clonedSoCategory = soCategoryRepository.save(newSoCate);
        			
        			if(coCategory != null) {
        				coCategory.setType(clonedSoCategory.getType());
        				coCategory.setSoCategory(clonedSoCategory);
    					coCategoryRepository.save(coCategory);
    				}
        			
        			List<SoCategoryFoodGroup> soCategoryFoodGroups = soCategory.getSoCategoryFoodGroups();
        			List<SoCategoryFoodGroup> sCFoodGroups = new ArrayList<>();
        			List<SoCategoryFoodGroup> sCFoodGroupHasParents = new ArrayList<>();
        			if (soCategoryFoodGroups != null && !soCategoryFoodGroups.isEmpty()) {
        				soCategoryFoodGroups.stream().forEach(scfg ->{
        					if(scfg.getFoodGroup().getParent() != null) {
        						sCFoodGroupHasParents.add(scfg);
        					} else {
        						sCFoodGroups.add(scfg);
        					}
        				});
        				
        				if(sCFoodGroups != null && !sCFoodGroups.isEmpty()) {
        					resetFoodGroups(sCFoodGroups, username, resCode, clonedSoCategory);
        				}
        				if(sCFoodGroupHasParents != null && !sCFoodGroupHasParents.isEmpty()) {
        					resetFoodGroups(sCFoodGroupHasParents, username, resCode, clonedSoCategory);
        				}
        			}
				}
			});
		}
	}
	
	//clone FoodGroup
	private void resetFoodGroups(List<SoCategoryFoodGroup> soCategoryFoodGroups,String username,Integer resCode,SoCategory soCategory) {
		log.debug("Entering 'deleteCategory(SoCategory soCategory)' method...");
		soCategoryFoodGroups.stream().forEach(scfg ->{
			FoodGroup foodGroup = scfg.getFoodGroup();
			FoodGroup newFoodGroup = new FoodGroup();
			newFoodGroup.setCode(foodGroup.getCode());
			newFoodGroup.setCreatedBy(username);
			newFoodGroup.setMenuType(foodGroup.getMenuType());
			newFoodGroup.setModifiedBy(username);
			newFoodGroup.setNameEn(foodGroup.getNameEn());
			if(foodGroup.getNameVn() != null && !foodGroup.getNameVn().isEmpty()) {
				newFoodGroup.setNameVn(foodGroup.getNameVn());
				newFoodGroup.setUnsignedName(org.apache.commons.lang3.StringUtils.stripAccents(foodGroup.getNameVn()).toLowerCase());
			}
			if(foodGroup.getParent() != null) {
				FoodGroup foodGroupParent = foodGroupRepository.findById(foodGroup.getParent().getId()).get();
				FoodGroup foodGroupParentNew = foodGroupRepository.findByCodeAndRestaurantCode(foodGroupParent.getCode(), resCode);
				newFoodGroup.setParent(foodGroupParentNew);
			}
			newFoodGroup.setLevel(foodGroup.getLevel());
			newFoodGroup.setSrcImage(foodGroup.getSrcImage());
			newFoodGroup.setRestaurantCode(resCode);
			newFoodGroup.setChanged(StatusEnum.INACTIVE.status);
			FoodGroup fg = foodGroupRepository.save(newFoodGroup);
			//clone attachment
			saveAttachment(foodGroup.getId(), fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
			//clone SoCategory
			SoCategoryFoodGroup newSoCategoryFoodGroup = new SoCategoryFoodGroup();
			newSoCategoryFoodGroup.setFoodGroup(fg);
			if(fg.getParent() != null) {
				newSoCategoryFoodGroup.setFoodGroupParentId(fg.getParent().getId());
			}
			newSoCategoryFoodGroup.setGroupOrder(scfg.getGroupOrder());
			newSoCategoryFoodGroup.setRestaurantCode(resCode);
			newSoCategoryFoodGroup.setSoCategory(soCategory);
			soCategoryFoodGroupRepository.save(newSoCategoryFoodGroup);
			//clone FoodGroupItem
			List<FoodGroupItem> foodGroupItems = foodGroupItemRepository.findByFoodGroupAndRestaurantCodeIsNull(foodGroup);
			foodGroupItems.stream().forEach(fgi -> {
				FoodGroupItem newFoodGroupItem = new FoodGroupItem();
				newFoodGroupItem.setFoodGroup(fg);
				newFoodGroupItem.setFoodItem(fgi.getFoodItem());
				newFoodGroupItem.setItemOrder(fgi.getItemOrder());
				newFoodGroupItem.setChanged(StatusEnum.ACTIVE.status);
				newFoodGroupItem.setRestaurantCode(resCode);
				foodGroupItemRepository.save(newFoodGroupItem);
			});
		});
	}
	
	//delete SoCategory
	private void deleteSoCategory(SoCategory soCategory) {
		log.debug("Entering 'deleteCategory(SoCategory soCategory)' method...");
		Set<FoodGroup> deletedFoodGroup = new HashSet<>();
		Set<FoodGroup> deletedFoodGroupHasParent = new HashSet<>();
		Integer resCode = soCategory.getRestaurantCode();
		
		// delete so-category-food-group
		List<SoCategoryFoodGroup> soCategoryFoodGroups = soCategoryFoodGroupRepository.findBySoCategoryAndRestaurantCode(soCategory.getId(), resCode);
		if(soCategoryFoodGroups != null && !soCategoryFoodGroups.isEmpty()) {
			soCategoryFoodGroups.stream().forEach(scfg ->{
				if(scfg.getFoodGroup().getParent() != null) {
					deletedFoodGroupHasParent.add(scfg.getFoodGroup());
				} else {
					deletedFoodGroup.add(scfg.getFoodGroup());
				}
				soCategoryFoodGroupRepository.delete(scfg);
			});
		}
		// delete food-group-item and food-group
		if(!deletedFoodGroupHasParent.isEmpty()) {
			deletedFoodGroupHasParent.stream().forEach(fg -> {
				foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(fg, resCode);
				delAttachment(fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
				foodGroupRepository.delete(fg);
			});
		}
		// delete food-group-item and food-group
		if(!deletedFoodGroup.isEmpty()) {
			deletedFoodGroup.stream().forEach(fg -> {
				foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(fg, resCode);
				delAttachment(fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
				foodGroupRepository.delete(fg);
			});
		}
		// delete SoCategory
		soCategoryRepository.delete(soCategory);
	}
	
	//apply catalog from resataurant
	public void applyToRes(final String username, final SoCategoryDto criteria) {
		log.info("Entering 'applyToRes(username, criteria)' method...");
		log.debug("Params: username: "+username+", soId: "+criteria.getSoId()+", toResCode: "+criteria.getRestaurantCode()+", isOverride: "+criteria.isOverride());

		Long soId = criteria.getSoId();
		Integer toResCode = criteria.getRestaurantCode();
		boolean isOverride = criteria.isOverride();
		So so = soRepository.getOne(soId);
		
		if(isOverride) {
			//saveSoCategory(So so,Integer resCode, boolean isOverride,boolean isCopyToRes,String username)
			saveSoCategory(so, toResCode, true, false, username);
			saveCatalogApply(toResCode,soId,true);
		} else {
			List<CatalogApplyToRestaurant> applyToRestaurants = catalogApplyToRestaurantRepository.findBySoId(soId);
			if(applyToRestaurants != null && !applyToRestaurants.isEmpty()) {
				List<Integer> resCodes = applyToRestaurants.stream().map(r -> r.getRestaurantCode()).collect(Collectors.toList());
				if(resCodes.contains(toResCode)) {
					saveSoCategory(so, toResCode, false, false, username);
				} else {
					saveSoCategory(so, toResCode, true, false, username);
				}
			} else {
				saveSoCategory(so, toResCode, true, false, username);
			}
			saveCatalogApply(toResCode,soId,false);
		}
		
	}
}