package com.gg.gpos.menu.manager;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import javax.transaction.Transactional;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import com.gg.gpos.common.constant.ModuleTypeEnum;
import com.gg.gpos.common.constant.StatusEnum;
import com.gg.gpos.common.constant.SymbolEnum;
import com.gg.gpos.common.json.ResponseData;
import com.gg.gpos.common.util.FancyTree;
import com.gg.gpos.menu.dto.SoDto;
import com.gg.gpos.menu.entity.CatalogApplyToRestaurant;
import com.gg.gpos.menu.entity.Co;
import com.gg.gpos.menu.entity.CoCategory;
import com.gg.gpos.menu.entity.CoFoodItem;
import com.gg.gpos.menu.entity.FoodGroup;
import com.gg.gpos.menu.entity.FoodGroupItem;
import com.gg.gpos.menu.entity.So;
import com.gg.gpos.menu.entity.SoCategory;
import com.gg.gpos.menu.entity.SoCategoryFoodGroup;
import com.gg.gpos.menu.mapper.SoMapper;
import com.gg.gpos.menu.repository.CatalogApplyToRestaurantRepository;
import com.gg.gpos.menu.repository.CoCategoryRepository;
import com.gg.gpos.menu.repository.CoFoodGroupDisplayRepository;
import com.gg.gpos.menu.repository.CoFoodItemModifierRepository;
import com.gg.gpos.menu.repository.CoFoodItemRepository;
import com.gg.gpos.menu.repository.CoRepository;
import com.gg.gpos.menu.repository.FoodGroupItemRepository;
import com.gg.gpos.menu.repository.FoodGroupRepository;
import com.gg.gpos.menu.repository.RelatedFoodItemRepository;
import com.gg.gpos.menu.repository.SoCategoryFoodGroupRepository;
import com.gg.gpos.menu.repository.SoCategoryRepository;
import com.gg.gpos.menu.repository.SoRepository;
import com.gg.gpos.menu.repository.ToppingFoodItemRepository;
import com.gg.gpos.menu.specification.SoSpecification;
import com.gg.gpos.reference.entity.Attachment;
import com.gg.gpos.reference.repository.AttachmentRepository;
import lombok.extern.slf4j.Slf4j;

/**
 * Generated by Speed Generator
 * 
 * @author <a href="mailto:ngtrungkien@gmail.com">Kien Nguyen</a>
 */
@Slf4j
@Service
@Transactional
public class SoManager {
	@Autowired
	private SoRepository soRepository;
	@Autowired
	private SoMapper soMapper;
	@Autowired
	private SoCategoryRepository soCategoryRepository;
	@Autowired
	private SoCategoryFoodGroupRepository soCategoryFoodGroupRepository;
	@Autowired
	private FoodGroupRepository foodGroupRepository;
	@Autowired
	private FoodGroupItemRepository foodGroupItemRepository;
	@Autowired
	private CoFoodItemRepository coFoodItemRepository;
	@Autowired
	private SoSpecification soSpecification;
	@Autowired
	private RelatedFoodItemRepository relatedFoodItemRepository;
	@Autowired
	private CoRepository coRepository;
	@Autowired
	private CoCategoryRepository coCategoryRepository;
	@Autowired
	private CoFoodGroupDisplayRepository coFoodGroupDisplayRepository;
	@Autowired
	private ToppingFoodItemRepository toppingFoodItemRepository;
	@Autowired
	private CatalogApplyToRestaurantRepository catalogApplyToRestaurantRepository;
	@Autowired
	private AttachmentRepository attachmentRepository;
	@Autowired
	private CoFoodItemModifierRepository coFoodItemModifierRepository;
	/*
	 * LẤY THÔNG TIN CHI TIẾT SO
	 */
	public SoDto get(Long id) {
		log.info("PROCESS: GET SO BY ID, SO_ID: {}", id);
		return soRepository.findById(id).map(soMapper::entityToDto).orElse(null);
	}
	
	public List<SoDto> gets() {
		return soRepository.findAll().stream().map(soMapper::entityToDto).collect(Collectors.toList());
	}
	
	/*
	 * TÌM KIẾM DANH SÁCH CÁC CATALOG SO CÓ TRẠNG THÁI TRUE
	 */
	public List<SoDto> getByStatusTrue() {
		log.info("PROCESS: GET SO BY STATUS IS TRUE");
		return soRepository.findByStatusIsTrue().stream().map(soMapper::entityToDto).collect(Collectors.toList());
	}
	
	public SoDto saveAfterChangeCatalog(Long id) {
		log.debug("PROCESS FUNCTION: SAVE SO_MENU AFTER CHANGE CATALOG, SO_MENU_ID: {}", id);
		So so = soRepository.findById(id).get();
		if(so != null) {
			so.setModifiedDate(LocalDateTime.now());
			return Optional.ofNullable(soRepository.save(so)).map(soMapper::entityToDto).orElse(null);
		} else {
			return null;
		}
	}
	
	public void saveAfterChangeCatalogs(Set<Long> soIds) {
		log.info("Entering 'SoDto saveAfterChangeCatalog(Long id)' method...");
		soIds.stream().forEach(id ->{
			So so = soRepository.findById(id).get();
			if(so != null) {
				so.setModifiedDate(LocalDateTime.now());
				soRepository.save(so);
			}
		});
	}
	
	public List<SoDto> getByStatusAndSoCategories(){
		log.debug("Entering 'getByStatusAndSoCategories' method...");
		
		List<So> source = soRepository.findStatusAndSoCategories();
		return source.stream().map(so -> {
			SoDto soDto = new SoDto();
			BeanUtils.copyProperties(so, soDto);
			return soDto;
		}).collect(Collectors.toList());
	}
	
	/*
	 * LƯU THÔNG TIN CATALOG SO
	 */
	public SoDto save(SoDto soDto) {
		log.info("PRCESS: SAVE CATALOG SO, SO: {}", soDto);
				
		So so = Optional.ofNullable(soDto).map(soMapper::dtoToEntity).orElse(null);
		if (so != null) {
			// kiểm tra trạng thái của SO. Nếu trạng thái OFF thì xóa dữ liệu SO và CO tương ứng
			if(so.getId() != null && !so.isStatus()) {
				offCo(so);
				off(so);
			}
			return Optional.ofNullable(soRepository.save(so)).map(soMapper::entityToDto).orElse(null);
		} else {
			return null;
		}
	}
	
	/*
	 * Hiển thị danh sách SO
	 */
	public Page<SoDto> gets(SoDto criteria){
		log.info("PROCESS: GETS SO, SO: {}", criteria);
		Page<So> page = soRepository.findAll(soSpecification.filter(criteria), PageRequest.of(criteria.getPage(), criteria.getSize(), Sort.by(Sort.Direction.DESC, "modifiedDate")));
		return new PageImpl<>(page.getContent().stream().map(soMapper::entityToDto).collect(Collectors.toList()), PageRequest.of(criteria.getPage(), criteria.getSize()), page.getTotalElements());
	}
	
	public boolean isApplied(Long id) {
		So so = new So();
		so.setId(id);
		List<SoCategory> list = soCategoryRepository.findBySoAndRestaurantCodeIsNotNull(so); 
		return (list != null && !list.isEmpty());
	}
	
	public void delete(Long id) {
		log.debug("Entering 'delete' method...");
		So so = new So();
		so.setId(id);
		soRepository.delete(so);
	}
	
	public ResponseData checkToOff(Long soId) {
		log.info("Entering 'checkToOff(soId)' method...");
		
		ResponseData res = new ResponseData();
		List<Integer> resCodes = soCategoryRepository.findRestaurantCodes(soId);
		if (resCodes != null && !resCodes.isEmpty()) {
			res.setData(resCodes);
			res.setResult(true);
			res.setSize(resCodes.size());
		} else {
			res.setResult(false);
		}
		return res;
	}
	
	
	/*
	 * Set lại trạng thái của danh mục CO theo trạng thái của danh mục SO
	 */
	private void offCo(So so) {
		log.info("PROCESS: OFF CATALOG CO AFTER OFF SO, SO: {}", so);
		List<Co> cos = coRepository.findBySoId(so.getId());
		if(cos != null && !cos.isEmpty()) {
			cos.stream().forEach(co ->{
				if(so.isStatus()) {
					co.setStatus(true);
					coRepository.save(co);
				}else {
					co.setStatus(false);
					coRepository.save(co);
				}
			});
		}
	}
	
	/*
	 * Xóa dữ liệu của SO và CO tương ứng
	 */
	private void off(final So so) {
		log.info("PROCESS: OFF AND DELETE DATA SO_CO, SO_ID: {}", so.getId());
		
		// LẤY DANH SÁCH NHÀ HÀNG ĐANG ĐƯỢC ÁP DỤNG DANH MỤC SO NÀY ĐỂ XÓA DỮ LIỆU SO VÀ CO
		List<CatalogApplyToRestaurant> applyToRestaurants = catalogApplyToRestaurantRepository.findBySoId(so.getId());
		if(applyToRestaurants != null && !applyToRestaurants.isEmpty()) {
			applyToRestaurants.stream().forEach(item -> {
				Integer resCode = item.getRestaurantCode();
				Set<Long> soCategoryIds = new HashSet<>();
				Set<FoodGroup> deletedFoodGroup = new HashSet<>();
				Set<FoodGroup> deletedFoodGroupHasParent = new HashSet<>();
				List<SoCategoryFoodGroup> soCategoryFoodGroups = soCategoryFoodGroupRepository.findByRestaurantCode(resCode);
				if (soCategoryFoodGroups != null && !soCategoryFoodGroups.isEmpty()) {
					soCategoryFoodGroups.stream().forEach(scfg -> {
						// pick so category for deletion
						soCategoryIds.add(scfg.getSoCategory().getId());
						// pick food group for deletion
						if(scfg.getFoodGroup().getParent() != null) {
							deletedFoodGroupHasParent.add(scfg.getFoodGroup());
						} else {
							deletedFoodGroup.add(scfg.getFoodGroup());
						}
						// delete so category food group
						soCategoryFoodGroupRepository.delete(scfg);
					});
				}
				// delete food-group-item and food-group
				if(!deletedFoodGroupHasParent.isEmpty()) {
					deletedFoodGroupHasParent.stream().forEach(fg -> {
						foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(fg, resCode);
						delAttachment(fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
						foodGroupRepository.delete(fg);
					});
				}
				// delete food-group-item and food-group
				if(!deletedFoodGroup.isEmpty()) {
					deletedFoodGroup.stream().forEach(fg -> {
						foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(fg, resCode);
						delAttachment(fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
						foodGroupRepository.delete(fg);
					});
				}
				// delete co_fooditem
				List<CoFoodItem> coFoodItems = coFoodItemRepository.findByRestaurantCode(resCode);
				if (coFoodItems != null && !coFoodItems.isEmpty()) {
					coFoodItems.stream().forEach(coFoodItem ->{
						coFoodItemModifierRepository.deleteByCoFoodItem(coFoodItem);
						relatedFoodItemRepository.deleteByCoFoodItem(coFoodItem);
						toppingFoodItemRepository.deleteByCoFoodItem(coFoodItem);
						delAttachment(coFoodItem.getId(), ModuleTypeEnum.CO_FOOD_ITEM.val);
						coFoodItemRepository.delete(coFoodItem);
					});
				}
				// delete cocategory
				List<CoCategory> coCategories = coCategoryRepository.findByRestaurantCode(resCode);
				if (coCategories != null && !coCategories.isEmpty()) {
					coCategories.stream().forEach(coCategory ->{
						coFoodGroupDisplayRepository.deleteByCoCategory(coCategory);
						delAttachment(coCategory.getId(), ModuleTypeEnum.CO_CATEGORY.val);
						coCategoryRepository.delete(coCategory);
					});
				}
				// delete so category
				soCategoryRepository.deleteByRestaurantCode(resCode);
				item.setCoId(null);
				item.setSoId(null);
				catalogApplyToRestaurantRepository.save(item);
			});
		}
	}
	
	// delete attachment
	private void delAttachment(Long moduleId,String moduleType) {
		log.info("Entering 'delAttachment(Long moduleId,String moduleType)' method...");
		log.debug("Params: moduleId: " + moduleId + ", moduleType: " + moduleType);
		List<Attachment> attachments = attachmentRepository.findByModuleIdAndModuleType(moduleId, moduleType);
		if(attachments != null && !attachments.isEmpty()) {
			attachments.stream().forEach(attachment ->{
				attachment.setModuleId(null);
				attachment.setFunctionType(null);
				attachment.setModuleType(ModuleTypeEnum.DEL_ATTACHMENT.val);
				attachment.setRestaurantCode(null);
				attachment.setSyncStatus(null);
				attachmentRepository.save(attachment);
			});
		}
	}

	//clone attachment
	private void saveAttachment(Long currentModuleId, Long newModuleId, String moduleType) {
		List<Attachment> attachments = attachmentRepository.findByModuleIdAndModuleType(currentModuleId, moduleType);
		if(attachments != null && !attachments.isEmpty()) {
			attachments.stream().forEach(item ->{
				Attachment attachment = new Attachment();
				attachment.setModuleId(newModuleId);
				attachment.setModuleType(moduleType);
				attachment.setFunctionType(item.getFunctionType());
				attachment.setName(item.getName());
				attachment.setUrl(item.getUrl());
				attachment.setAbsolutePath(item.getAbsolutePath());
				attachment.setFileName(item.getFileName());
				attachment.setFileType(item.getFileType());
				attachment.setVersion(item.getVersion());
				attachmentRepository.save(attachment);
			});
		}
	}

	// getTree catalog
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public FancyTree getTree(FancyTree comNode) {
		log.debug("entering 'getTree' method...");
		// set node so
		List<So> soLst = soRepository.findByStatusIsTrue();
    	if (!soLst.isEmpty()) {
    		List soNodes = new ArrayList();
    		soLst.stream().forEach(so -> {
    			FancyTree soNode = new FancyTree();
    			soNode.setTitle(so.getName());
    			List<SoCategory> soCategories = soCategoryRepository.findBySoAndRestaurantCodeIsNull(so);
    			if (soCategories != null && !soCategories.isEmpty()) {
    				List soCategoryNodes = new ArrayList();
    				soCategories.stream().forEach(soCategory -> {
    					FancyTree soCategoryNode = new FancyTree();
    					StringBuilder title = new StringBuilder();
						title.append(soCategory.getOrderCategory().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(soCategory.getOrderCategory().getName());
    					soCategoryNode.setTitle(title.toString());
							List<FoodGroup> foodGroups = foodGroupRepository.findByRCodeIsNullAndScIdAndChanged(soCategory.getId(),StatusEnum.DELETE.status);
							if (foodGroups != null && !foodGroups.isEmpty()) {
								List foodGroupNodes = new ArrayList();
								foodGroups.stream().forEach(fg -> {
									FancyTree foodGroupNode = new FancyTree();
									StringBuilder titleFg = new StringBuilder();
									titleFg.append(fg.getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fg.getNameVn());
									StringBuilder keyFg = new StringBuilder();
									// foodGroupCode - soCategoryId - SoId
									keyFg.append(fg.getCode()).append(SymbolEnum.HYPHEN.val).append(soCategory.getId()).append(SymbolEnum.HYPHEN.val).append(so.getId());
									foodGroupNode.setTitle(titleFg.toString());
									foodGroupNode.setKey(keyFg.toString());
									foodGroupNodes.add(foodGroupNode);
								});
								soCategoryNode.setChildren(foodGroupNodes);
							}
						soCategoryNodes.add(soCategoryNode);
    				});
    				soNode.setChildren(soCategoryNodes);
    			}
    			soNodes.add(soNode);
    		});
    		comNode.setChildren(soNodes);
    	}
    	return comNode;
	}
	
	// find by keyword FoodItem
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public FancyTree getTree(String keywordFoodGroup,String keywordFoodItem, FancyTree comNode,List<String> fICodeSelected,List<String> fGCodeSelected) {
		log.debug("entering 'getTree' method...");
		// set node so
		if(keywordFoodItem != null && !keywordFoodItem.isEmpty()) {
			List<FoodGroup> fGroups = new ArrayList<>();
			List<FoodGroupItem> fGItems = new ArrayList<>();

			if(keywordFoodItem != null && !keywordFoodItem.isEmpty() && keywordFoodGroup != null && !keywordFoodGroup.isEmpty()) {
				fGItems = foodGroupItemRepository.findByFiCodeorNameAndFgCodeorNameAndChanged(org.apache.commons.lang3.StringUtils.stripAccents(keywordFoodItem).toLowerCase(),StatusEnum.DELETE.status,org.apache.commons.lang3.StringUtils.stripAccents(keywordFoodGroup).toLowerCase());
			}else if(keywordFoodItem != null && !keywordFoodItem.isEmpty() && (keywordFoodGroup == null || keywordFoodGroup.isEmpty())) {
				fGItems = foodGroupItemRepository.findByFiCodeorNameAndChanged(org.apache.commons.lang3.StringUtils.stripAccents(keywordFoodItem).toLowerCase(),StatusEnum.DELETE.status);
				System.out.println("fGroups :" + fGroups);
			}
			fGroups.addAll(fGItems.stream().map(item -> item.getFoodGroup()).collect(Collectors.toList()));
			List<String> fgCodes = fGroups.stream().map(item -> item.getCode()).collect(Collectors.toList());
			List<String> fiCodes = fGItems.stream().map(item -> item.getFoodItem().getCode()).collect(Collectors.toList());
			System.out.println("fgCodes :" + fgCodes);
			List<SoCategory> categories = fGroups.stream().map(item -> item.getSoCategoryFoodGroups().get(0).getSoCategory()).collect(Collectors.toList());
			System.out.println("categories :" + categories);
			if(categories != null && !categories.isEmpty()) {
				List<Long> soCategoryIds = categories.stream().map(item -> item.getId()).collect(Collectors.toList());
				System.out.println("soCategoryIds :" + soCategoryIds);
				List<Long> soIds = categories.stream().map(item -> item.getSo().getId()).collect(Collectors.toList());
				List<So> soLst = soRepository.findByStatusIsTrue();
		    	if (!soLst.isEmpty()) {
		    		List soNodes = new ArrayList();
		    		soLst.stream().forEach(so -> {
		    			if(soIds.contains(so.getId())) {
		    				FancyTree soNode = new FancyTree();
			    			soNode.setTitle(so.getName());
			    			List<SoCategory> soCategories = soCategoryRepository.findBySoAndRestaurantCodeIsNull(so);
			    			if (soCategories != null && !soCategories.isEmpty()) {
			    				List soCategoryNodes = new ArrayList();
			    				soCategories.stream().forEach(soCategory -> {
			    					if(soCategoryIds.contains(soCategory.getId())) {
			    						FancyTree soCategoryNode = new FancyTree();
				    					StringBuilder title = new StringBuilder();
										title.append(soCategory.getOrderCategory().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(soCategory.getOrderCategory().getName());
				    					soCategoryNode.setTitle(title.toString());
											List<FoodGroup> foodGroups = foodGroupRepository.findByRCodeIsNullAndScIdAndChanged(soCategory.getId(),StatusEnum.DELETE.status);
											if (foodGroups != null && !foodGroups.isEmpty()) {
												List foodGroupNodes = new ArrayList();
												foodGroups.stream().forEach(fg -> {
													if(fgCodes.contains(fg.getCode())) {
														FancyTree foodGroupNode = new FancyTree();
														StringBuilder titleFg = new StringBuilder();
														titleFg.append(fg.getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fg.getNameVn());
														foodGroupNode.setTitle(titleFg.toString());
															List<FoodGroupItem> foodGroupItems = fg.getFoodGroupItems();
															if(foodGroupItems != null && !foodGroupItems.isEmpty()) {
																List foodGroupItemNodes = new ArrayList();
																foodGroupItems.stream().forEach(fgi ->{
																	if(fiCodes.contains(fgi.getFoodItem().getCode())) {
																		FancyTree foodGroupItemNode = new FancyTree();
																		StringBuilder titleFgi = new StringBuilder();
																		String sapCode = "";
																		if(fgi.getFoodItem().getSapCode() != null && !fgi.getFoodItem().getSapCode().isEmpty()) {
																			sapCode = fgi.getFoodItem().getSapCode();
																		}
																		titleFgi.append(sapCode).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fgi.getFoodItem().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fgi.getFoodItem().getName());
																		foodGroupItemNode.setTitle(titleFgi.toString());
																		StringBuilder keyFg = new StringBuilder();
																		// foodGroupCode - soCategoryId - SoId - foodItemCode
																		keyFg.append(fg.getCode()).append(SymbolEnum.HYPHEN.val).append(soCategory.getId()).append(SymbolEnum.HYPHEN.val).append(so.getId()).append(SymbolEnum.HYPHEN.val).append(fgi.getFoodItem().getCode());
																		foodGroupItemNode.setKey(keyFg.toString());
																		if (fICodeSelected != null && !fICodeSelected.isEmpty() && fICodeSelected.contains(fgi.getFoodItem().getCode())) {
																			foodGroupItemNode.setSelected(true);
																		}
																		foodGroupItemNodes.add(foodGroupItemNode);
																	}
																});
																foodGroupNode.setChildren(foodGroupItemNodes);
															}
														foodGroupNodes.add(foodGroupNode);
													}
												});
												soCategoryNode.setChildren(foodGroupNodes);
											}
										soCategoryNodes.add(soCategoryNode);
			    					}
			    				});
			    				soNode.setChildren(soCategoryNodes);
			    			}
			    			soNodes.add(soNode);
		    			}
		    		});
		    		comNode.setChildren(soNodes);
		    	}
			}
		} else {
			List<So> soLst = soRepository.findByStatusIsTrue();
	    	if (!soLst.isEmpty()) {
	    		List soNodes = new ArrayList();
	    		soLst.stream().forEach(so -> {
	    			FancyTree soNode = new FancyTree();
	    			soNode.setTitle(so.getName());
	    			List<SoCategory> soCategories = soCategoryRepository.findBySoAndRestaurantCodeIsNull(so);
	    			if (soCategories != null && !soCategories.isEmpty()) {
	    				List soCategoryNodes = new ArrayList();
	    				soCategories.stream().forEach(soCategory -> {
	    					FancyTree soCategoryNode = new FancyTree();
	    					StringBuilder title = new StringBuilder();
							title.append(soCategory.getOrderCategory().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(soCategory.getOrderCategory().getName());
	    					soCategoryNode.setTitle(title.toString());
								List<FoodGroup> foodGroups = foodGroupRepository.findByRCodeIsNullAndScIdAndChanged(soCategory.getId(),StatusEnum.DELETE.status);
								if (foodGroups != null && !foodGroups.isEmpty()) {
									List foodGroupNodes = new ArrayList();
									foodGroups.stream().forEach(fg -> {
										FancyTree foodGroupNode = new FancyTree();
										StringBuilder titleFg = new StringBuilder();
										titleFg.append(fg.getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fg.getNameVn());
										foodGroupNode.setTitle(titleFg.toString());
											List<FoodGroupItem> foodGroupItems = fg.getFoodGroupItems();
												if(foodGroupItems != null && !foodGroupItems.isEmpty()) {
													List foodGroupItemNodes = new ArrayList();
													foodGroupItems.stream().forEach(fgi ->{
														FancyTree foodGroupItemNode = new FancyTree();
														StringBuilder titleFgi = new StringBuilder();
														String sapCode = "";
														if(fgi.getFoodItem().getSapCode() != null && !fgi.getFoodItem().getSapCode().isEmpty()) {
															sapCode = fgi.getFoodItem().getSapCode();
														}
														titleFgi.append(sapCode).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fgi.getFoodItem().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fgi.getFoodItem().getName());
														foodGroupItemNode.setTitle(titleFgi.toString());
														StringBuilder keyFg = new StringBuilder();
														// foodGroupCode - soCategoryId - SoId - foodItemCode
														keyFg.append(fg.getCode()).append(SymbolEnum.HYPHEN.val).append(soCategory.getId()).append(SymbolEnum.HYPHEN.val).append(so.getId()).append(SymbolEnum.HYPHEN.val).append(fgi.getFoodItem().getCode());
														foodGroupItemNode.setKey(keyFg.toString());
														if (fICodeSelected != null && !fICodeSelected.isEmpty() && fICodeSelected.contains(fgi.getFoodItem().getCode())) {
															foodGroupItemNode.setSelected(true);
														}
														foodGroupItemNodes.add(foodGroupItemNode);
													});
													foodGroupNode.setChildren(foodGroupItemNodes);
												}
										foodGroupNodes.add(foodGroupNode);
									});
									soCategoryNode.setChildren(foodGroupNodes);
								}
							soCategoryNodes.add(soCategoryNode);
	    				});
	    				soNode.setChildren(soCategoryNodes);
	    			}
	    			soNodes.add(soNode);
	    		});
	    		comNode.setChildren(soNodes);
	    	}
		}
		
    	return comNode;
	}
	
	
	// find by keyword - foodGroup
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public FancyTree getTree(String keyword, FancyTree comNode,List<String> fGCodeSelected) {
		log.debug("entering 'getTree' method...");
		// set node so
		if(keyword != null && !keyword.isEmpty()) {
			List<FoodGroup> fGroups = new ArrayList<>();
			if(keyword != null && !keyword.isEmpty()) {
				System.out.println("org.apache.commons.lang3.StringUtils.stripAccents(keyword) :"+ org.apache.commons.lang3.StringUtils.stripAccents(keyword));
				fGroups = foodGroupRepository.findByCodeOrNameVn(org.apache.commons.lang3.StringUtils.stripAccents(keyword).toLowerCase(),StatusEnum.DELETE.status);
				System.out.println("fGroups :" + fGroups);
			}
			if(fGCodeSelected != null && !fGCodeSelected.isEmpty()) {
				fGroups.addAll(foodGroupRepository.findByFGCodeIn(fGCodeSelected, StatusEnum.DELETE.status));
			}
			
			List<String> fgCodes = fGroups.stream().map(item -> item.getCode()).collect(Collectors.toList());
			System.out.println("fgCodes :" + fgCodes);
			List<SoCategory> categories = fGroups.stream().map(item -> item.getSoCategoryFoodGroups().get(0).getSoCategory()).collect(Collectors.toList());
			System.out.println("categories :" + categories);
			if(categories != null && !categories.isEmpty()) {
				List<Long> soCategoryIds = categories.stream().map(item -> item.getId()).collect(Collectors.toList());
				System.out.println("soCategoryIds :" + soCategoryIds);
				List<Long> soIds = categories.stream().map(item -> item.getSo().getId()).collect(Collectors.toList());
				List<So> soLst = soRepository.findByStatusIsTrue();
		    	if (!soLst.isEmpty()) {
		    		List soNodes = new ArrayList();
		    		soLst.stream().forEach(so -> {
		    			if(soIds.contains(so.getId())) {
		    				FancyTree soNode = new FancyTree();
			    			soNode.setTitle(so.getName());
			    			List<SoCategory> soCategories = soCategoryRepository.findBySoAndRestaurantCodeIsNull(so);
			    			if (soCategories != null && !soCategories.isEmpty()) {
			    				List soCategoryNodes = new ArrayList();
			    				soCategories.stream().forEach(soCategory -> {
			    					if(soCategoryIds.contains(soCategory.getId())) {
			    						FancyTree soCategoryNode = new FancyTree();
				    					StringBuilder title = new StringBuilder();
										title.append(soCategory.getOrderCategory().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(soCategory.getOrderCategory().getName());
				    					soCategoryNode.setTitle(title.toString());
											List<FoodGroup> foodGroups = foodGroupRepository.findByRCodeIsNullAndScIdAndChanged(soCategory.getId(),StatusEnum.DELETE.status);
											if (foodGroups != null && !foodGroups.isEmpty()) {
												List foodGroupNodes = new ArrayList();
												foodGroups.stream().forEach(fg -> {
													if(fgCodes.contains(fg.getCode())) {
														FancyTree foodGroupNode = new FancyTree();
														StringBuilder titleFg = new StringBuilder();
														titleFg.append(fg.getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fg.getNameVn());
														StringBuilder keyFg = new StringBuilder();
														// foodGroupCode - soCategoryId - SoId
														keyFg.append(fg.getCode()).append(SymbolEnum.HYPHEN.val).append(soCategory.getId()).append(SymbolEnum.HYPHEN.val).append(so.getId());
														foodGroupNode.setTitle(titleFg.toString());
														foodGroupNode.setKey(keyFg.toString());
														if (fGCodeSelected != null && !fGCodeSelected.isEmpty() && fGCodeSelected.contains(fg.getCode())) {
															foodGroupNode.setSelected(true);
														}
														foodGroupNodes.add(foodGroupNode);
													}
												});
												soCategoryNode.setChildren(foodGroupNodes);
											}
										soCategoryNodes.add(soCategoryNode);
			    					}
			    				});
			    				soNode.setChildren(soCategoryNodes);
			    			}
			    			soNodes.add(soNode);
		    			}
		    		});
		    		comNode.setChildren(soNodes);
		    	}
			}
		} else {
			List<So> soLst = soRepository.findByStatusIsTrue();
	    	if (!soLst.isEmpty()) {
	    		List soNodes = new ArrayList();
	    		soLst.stream().forEach(so -> {
	    			FancyTree soNode = new FancyTree();
	    			soNode.setTitle(so.getName());
	    			List<SoCategory> soCategories = soCategoryRepository.findBySoAndRestaurantCodeIsNull(so);
	    			if (soCategories != null && !soCategories.isEmpty()) {
	    				List soCategoryNodes = new ArrayList();
	    				soCategories.stream().forEach(soCategory -> {
	    					FancyTree soCategoryNode = new FancyTree();
	    					StringBuilder title = new StringBuilder();
							title.append(soCategory.getOrderCategory().getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(soCategory.getOrderCategory().getName());
	    					soCategoryNode.setTitle(title.toString());
								List<FoodGroup> foodGroups = foodGroupRepository.findByRCodeIsNullAndScIdAndChanged(soCategory.getId(),StatusEnum.DELETE.status);
								if (foodGroups != null && !foodGroups.isEmpty()) {
									List foodGroupNodes = new ArrayList();
									foodGroups.stream().forEach(fg -> {
										FancyTree foodGroupNode = new FancyTree();
										StringBuilder titleFg = new StringBuilder();
										titleFg.append(fg.getCode()).append(SymbolEnum.SPACE.val).append(SymbolEnum.HYPHEN.val).append(SymbolEnum.SPACE.val).append(fg.getNameVn());
										StringBuilder keyFg = new StringBuilder();
										// foodGroupCode - soCategoryId - SoId
										keyFg.append(fg.getCode()).append(SymbolEnum.HYPHEN.val).append(soCategory.getId()).append(SymbolEnum.HYPHEN.val).append(so.getId());
										foodGroupNode.setTitle(titleFg.toString());
										foodGroupNode.setKey(keyFg.toString());
										if (fGCodeSelected != null && !fGCodeSelected.isEmpty() && fGCodeSelected.contains(fg.getCode())) {
											foodGroupNode.setSelected(true);
										}
										foodGroupNodes.add(foodGroupNode);
									});
									soCategoryNode.setChildren(foodGroupNodes);
								}
							soCategoryNodes.add(soCategoryNode);
	    				});
	    				soNode.setChildren(soCategoryNodes);
	    			}
	    			soNodes.add(soNode);
	    		});
	    		comNode.setChildren(soNodes);
	    	}
		}
		
    	return comNode;
	}

	
	//reset SoCategory
	public void resetSoCategory(Integer resCode,String username) {
		log.debug("Entering 'resetSoCategory(Integer resCode,String username)' method...");
		CatalogApplyToRestaurant applyToRestaurant = catalogApplyToRestaurantRepository.findByRestaurantCode(resCode);
		List<SoCategory> soCateInRes = soCategoryRepository.findByRestaurantCodeAndSoIsNull(resCode);
		if(soCateInRes != null && !soCateInRes.isEmpty() && applyToRestaurant != null && applyToRestaurant.getSoId() != null) {
			soCateInRes.stream().forEach(item ->{
				String orderCategoryCode = item.getOrderCategory().getCode();
				SoCategory soCategory = soCategoryRepository.findByOrderCategoryCodeAndSoIdAndResCodeIsNull(orderCategoryCode, applyToRestaurant.getSoId());
				CoCategory coCategory = coCategoryRepository.findBySoCategoryAndRestaurantCode(item, resCode);
				if(soCategory != null) {
					// delete SoCategory
					deleteSoCategory(item);
					
					SoCategory newSoCate = new SoCategory();
					newSoCate.setAdultBufferTicket(soCategory.getAdultBufferTicket());
					newSoCate.setKidBufferTicket(soCategory.getKidBufferTicket());
					newSoCate.setOrderCategory(soCategory.getOrderCategory());
					newSoCate.setOrderCategoryParentId(soCategory.getOrderCategoryParentId());
					newSoCate.setRestaurantCode(resCode);
					newSoCate.setType(soCategory.getType());
					newSoCate.setSo(soCategory.getSo());
        			SoCategory clonedSoCategory = soCategoryRepository.save(newSoCate);
        			
        			if(coCategory != null) {
        				coCategory.setType(clonedSoCategory.getType());
        				coCategory.setSoCategory(clonedSoCategory);
    					coCategoryRepository.save(coCategory);
    				}
        			
        			List<SoCategoryFoodGroup> soCategoryFoodGroups = soCategory.getSoCategoryFoodGroups();
        			List<SoCategoryFoodGroup> sCFoodGroups = new ArrayList<>();
        			List<SoCategoryFoodGroup> sCFoodGroupHasParents = new ArrayList<>();
        			if (soCategoryFoodGroups != null && !soCategoryFoodGroups.isEmpty()) {
        				soCategoryFoodGroups.stream().forEach(scfg ->{
        					if(scfg.getFoodGroup().getParent() != null) {
        						sCFoodGroupHasParents.add(scfg);
        					} else {
        						sCFoodGroups.add(scfg);
        					}
        				});
        				
        				if(sCFoodGroups != null && !sCFoodGroups.isEmpty()) {
        					resetFoodGroups(sCFoodGroups, username, resCode, clonedSoCategory);
        				}
        				if(sCFoodGroupHasParents != null && !sCFoodGroupHasParents.isEmpty()) {
        					resetFoodGroups(sCFoodGroupHasParents, username, resCode, clonedSoCategory);
        				}
        			}
				}
			});
		}
	}
	
	//clone FoodGroup
	private void resetFoodGroups(List<SoCategoryFoodGroup> soCategoryFoodGroups,String username,Integer resCode,SoCategory soCategory) {
		log.debug("Entering 'deleteCategory(SoCategory soCategory)' method...");
		soCategoryFoodGroups.stream().forEach(scfg ->{
			FoodGroup foodGroup = scfg.getFoodGroup();
			FoodGroup newFoodGroup = new FoodGroup();
			newFoodGroup.setCode(foodGroup.getCode());
			newFoodGroup.setCreatedBy(username);
			newFoodGroup.setMenuType(foodGroup.getMenuType());
			newFoodGroup.setModifiedBy(username);
			newFoodGroup.setNameEn(foodGroup.getNameEn());
			if(foodGroup.getNameVn() != null && !foodGroup.getNameVn().isEmpty()) {
				newFoodGroup.setNameVn(foodGroup.getNameVn());
				newFoodGroup.setUnsignedName(org.apache.commons.lang3.StringUtils.stripAccents(foodGroup.getNameVn()).toLowerCase());
			}
			if(foodGroup.getParent() != null) {
				FoodGroup foodGroupParent = foodGroupRepository.findById(foodGroup.getParent().getId()).get();
				FoodGroup foodGroupParentNew = foodGroupRepository.findByCodeAndRestaurantCode(foodGroupParent.getCode(), resCode);
				newFoodGroup.setParent(foodGroupParentNew);
			}
			newFoodGroup.setLevel(foodGroup.getLevel());
			newFoodGroup.setSrcImage(foodGroup.getSrcImage());
			newFoodGroup.setRestaurantCode(resCode);
			newFoodGroup.setChanged(StatusEnum.INACTIVE.status);
			FoodGroup fg = foodGroupRepository.save(newFoodGroup);
			//clone attachment
			saveAttachment(foodGroup.getId(), fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
			//clone SoCategory
			SoCategoryFoodGroup newSoCategoryFoodGroup = new SoCategoryFoodGroup();
			newSoCategoryFoodGroup.setFoodGroup(fg);
			if(fg.getParent() != null) {
				newSoCategoryFoodGroup.setFoodGroupParentId(fg.getParent().getId());
			}
			newSoCategoryFoodGroup.setGroupOrder(scfg.getGroupOrder());
			newSoCategoryFoodGroup.setRestaurantCode(resCode);
			newSoCategoryFoodGroup.setSoCategory(soCategory);
			soCategoryFoodGroupRepository.save(newSoCategoryFoodGroup);
			//clone FoodGroupItem
			List<FoodGroupItem> foodGroupItems = foodGroupItemRepository.findByFoodGroupAndRestaurantCodeIsNull(foodGroup);
			foodGroupItems.stream().forEach(fgi -> {
				FoodGroupItem newFoodGroupItem = new FoodGroupItem();
				newFoodGroupItem.setFoodGroup(fg);
				newFoodGroupItem.setFoodItem(fgi.getFoodItem());
				newFoodGroupItem.setItemOrder(fgi.getItemOrder());
				newFoodGroupItem.setChanged(StatusEnum.ACTIVE.status);
				newFoodGroupItem.setRestaurantCode(resCode);
				foodGroupItemRepository.save(newFoodGroupItem);
			});
		});
	}
	
	//delete SoCategory
	private void deleteSoCategory(SoCategory soCategory) {
		log.debug("Entering 'deleteCategory(SoCategory soCategory)' method...");
		Set<FoodGroup> deletedFoodGroup = new HashSet<>();
		Set<FoodGroup> deletedFoodGroupHasParent = new HashSet<>();
		Integer resCode = soCategory.getRestaurantCode();
		
		// delete so-category-food-group
		List<SoCategoryFoodGroup> soCategoryFoodGroups = soCategoryFoodGroupRepository.findBySoCategoryAndRestaurantCode(soCategory.getId(), resCode);
		if(soCategoryFoodGroups != null && !soCategoryFoodGroups.isEmpty()) {
			soCategoryFoodGroups.stream().forEach(scfg ->{
				if(scfg.getFoodGroup().getParent() != null) {
					deletedFoodGroupHasParent.add(scfg.getFoodGroup());
				} else {
					deletedFoodGroup.add(scfg.getFoodGroup());
				}
				soCategoryFoodGroupRepository.delete(scfg);
			});
		}
		// delete food-group-item and food-group
		if(!deletedFoodGroupHasParent.isEmpty()) {
			deletedFoodGroupHasParent.stream().forEach(fg -> {
				foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(fg, resCode);
				delAttachment(fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
				foodGroupRepository.delete(fg);
			});
		}
		// delete food-group-item and food-group
		if(!deletedFoodGroup.isEmpty()) {
			deletedFoodGroup.stream().forEach(fg -> {
				foodGroupItemRepository.deleteByFoodGroupAndRestaurantCode(fg, resCode);
				delAttachment(fg.getId(), ModuleTypeEnum.FOOD_GROUP.val);
				foodGroupRepository.delete(fg);
			});
		}
		// delete SoCategory
		soCategoryRepository.delete(soCategory);
	}
}